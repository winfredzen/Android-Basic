# 应用程序进程启动过程

参考：

+ 《Android进阶解密》



启动一个应用程序首先要保证该应用程序的进程已近被启动

AMS在启动应用程序时会检查这个应用程序需要的应用程序进程是否存在，不存在就请求Zygote进程启动需要的应用程序进程。

Zygote的Java框架层中会创建一个Server端的Socket，这个Socket用来等待AMS请求Zygote来创建新的应用程序进程。

Zygote进程通过fork自身创建应用程序进程，这样应用程序进程就会获得Zygote进程在启动时创建的**虚拟机实例**

在应用程序进程创建过程中除了获取**虚拟机实例**外，还创建了**Binder线程池**和**消息循环**，这样运行在应用进程中的应用程序就可以方便地**使用Binder进行进程间通信**以及**处理消息**了



## 1.AMS发送启动应用程序进程请求

![055](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/055.png)

在当前Android 12中，流程稍微有些差别

会通过`ProcessList`（`frameworks/base/services/core/java/com/android/server/am/ProcessList.java`）来进程调用

`ProcessList`的`startProcessLocked`方法：

```java
    @GuardedBy("mService")
    boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,
            int zygotePolicyFlags, boolean disableHiddenApiChecks, boolean disableTestApiChecks,
            String abiOverride) {

				...

        try {
            final int userId = UserHandle.getUserId(app.uid);
            try {
                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }

            int uid = app.uid;//获取要创建的应用程序进程的用户ID
            int[] gids = null;

            ...

            app.setGids(gids);
            app.setRequiredAbi(requiredAbi);
            app.setInstructionSet(instructionSet);

  					...
            //应用程序进程主线程的类名  
            final String entryPoint = "android.app.ActivityThread";

            return startProcessLocked(hostingRecord, entryPoint, app, uid, gids,
                    runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,
                    instructionSet, invokeWith, startUptime, startElapsedTime);
        } catch (RuntimeException e) {
           
        }
    }
```



## 2.Zygote接收请求并创建应用程序进程

![056](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/056.png)

可见，最终会进入`ActivityThread`的`main`方法中

























