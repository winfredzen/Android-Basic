# init进程

参考：

+ [Android 开发之——zygote进程原理详解，彻底理解zygote机制与内核设计](https://www.bilibili.com/video/BV1Z5411H7Gq?p=1&vd_source=308fc9b57cdc925a463da02262234ff6)



`ps`命令参考：

+ [Linux ps命令详解：查看正在运行的进程](http://c.biancheng.net/view/1062.html)
+ [10个重要的Linux ps命令实战](https://linux.cn/article-4743-1.html)



`kill`命令参考：

+ [Linux kill命令详解：终止进程](http://c.biancheng.net/view/1068.html)



`init`进程时Android手机启动的第一个进程

+ 守护系统核心服务
+ 启动需要的服务

![004](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/004.png)



`adb shell`进入shell后，输入`ps -A` 列出所有的进程

在本人`Google Pixel Android 10`的系统的手机上，显示的内容如下：

![002](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/002.png)

可见，第一个进程就是`init`进程

> `USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME` 含义说明

> `USER `- 该 process 属于那个使用者账号的
>
> `PID`  - 该 process 的号码
>
> `PPID`  - 其上级父程序的ID



从上面的例子中，也可以看到有很多进程的父进程为`init`进程

![003](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/003.png)



如果试图强制结束某个父进程为`init`的进程，会是什么效果？

> 如结束掉`netd`进程?
>
> 1.查找`netd`进程，`ps -ef | grep netd | grep -v grep`，显示出所有的`netd`进程，去处掉当前的`grep`进程。
>
> ```java
> root           626     1 0 23:45:40 ?     00:00:01 netd
> ```
>
> 2.获取到`pid`为626，结束到此进程`kill -9 626`
>
> ```shell
> kill -9 626
> ```
>
> 3.再通过`ps -ef | grep netd | grep -v grep`，查找`netd`进程，显示如下：
>
> ```sh
> root          7718     1 1 00:26:34 ?     00:00:00 netd
> ```
>
> 可以发现，`netd`进程又被重启了，并没有被kill掉



## init.rc

手机厂商实现自动启动服务？`init.rc`

![005](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/005.png)

如在`init.zygote32.rc`中的内容

![006](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/006.png)

```java
service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
    class main
    priority -20
    user root
    group root readproc reserved_disk
    socket zygote stream 660 root system
    socket usap_pool_primary stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    onrestart restart wificond
    writepid /dev/cpuset/foreground/tasks
```

> service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
>
> 执行service命令，启动zygote，可执行文件位于`/system/bin/app_process`

![007](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/007.png)



`app_process`是`app_main.cpp`编译而来的，在其`main`函数中

![016](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/016.png)

![017](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/017.png)

> `runtime.start("com.android.internal.os.ZygoteInit", args, zygote);`
>
> 启动`ZygoteInit`



**ZygoteInit**

`ZygoteInit`中有个`ZygoteServer`

![018](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/018.png)



`ZygoteServer`中有个[LocalServerSocket](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/net/LocalServerSocket.java;drc=2dbfe014f76bc8789af9f74ef42e908e0fcc39e6;l=27) 变量

![019](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/019.png)

*so，为什么使用socket来通信？*

> binder虽然性能比较高，但容易被hook，有安全性方面的问题



`ZygoteInit`预加载类，`preload`->`preloadClasses`

![020](https://github.com/winfredzen/Android-Basic/blob/master/Framework/images/020.png)

> 路径为`/system/etc/preloaded-classes`
>
> 包括`android.app.Activity`、`android.app.ActivityManager`等







