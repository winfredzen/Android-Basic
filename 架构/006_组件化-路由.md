# 组件化-路由

内容来自：

+ [Android组件化实战（二）](https://www.bilibili.com/video/BV1X5411A7dc)



首先下了解**注解**：

+ [注解](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144)



APT教程：

+ [Android APT快速教程](https://juejin.cn/post/6844903696900292621)
+ [详细介绍编译时注解的使用方法](https://juejin.cn/post/6844903441215520775)



在上一节的例子中，页面之间的跳转，使用的是如下的方式：

```java
    public void toOrderModule(View view) {
        //传统方式，组件间的相互调用
        startActivity(new Intent(MainActivity.this, OrderMainActivity.class));
    }

    public void toPersonalModule(View view) {
        startActivity(new Intent(MainActivity.this, PersonalMainActivity.class));
    }
```

这种方式的跳转，页面之间的耦合度比较高

**所以更好的方式是使用路由的方式来解决**



## APT & JavaPoet

APT(Annotation Processing Tool)即**注解处理器**，是一种用来处理注解的工具。JVM会在**编译期**就运行APT去扫描处理代码中的注解然后输出java文件。

`JavaPoet` is a Java API for generating `.java` source files.`JavaPoet` 可以用来生成`.java` 源文件



APT技术可以理解为：把自定义的注解，变成java代码，其中有两种方式：

+ 手动一行一行的写，如`EventBus`中的`EventBusAnnotationProcessor`

  ![019](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/019.png)

+ 通过使用JavaPoet，面向对象的思想进行编码



### annotation模块

创建annotation模块时，选择`Java or Kotlin Library`

![020](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/020.png)

创建`ARouter`注解

```java
@Target(ElementType.TYPE) //作用于类上
@Retention(RetentionPolicy.SOURCE) //编译期生效
public @interface ARouter {
    String path();

    String group() default ""; // 组
}
```

`build.gradle`文件内容

```groovy
plugins {
    id 'java-library'
}

// 控制台中文设置UTF-8（由于是编译期的输出，所以要指定一个UTF-8的编码）
tasks.withType(JavaCompile){
    options.encoding = "UTF-8"
}

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}
```



### annotation processor

创建`annotation_processor`模块，如下：

![021](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/021.png)





> **AutoService**注解处理器是Google开发的，用来生成 **META-INF/services/javax.annotation.processing.Processor** 文件的，你只需要在你定义的注解处理器上添加 @AutoService(Processor.class) 就可以了，简直不能再方便了。













































