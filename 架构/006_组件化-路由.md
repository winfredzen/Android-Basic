# 组件化-路由

内容来自：

+ [Android组件化实战（二）](https://www.bilibili.com/video/BV1X5411A7dc)



首先下了解**注解**：

+ [注解](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144)



APT教程：

+ [Android APT快速教程](https://juejin.cn/post/6844903696900292621)
+ [详细介绍编译时注解的使用方法](https://juejin.cn/post/6844903441215520775)



在上一节的例子中，页面之间的跳转，使用的是如下的方式：

```java
    public void toOrderModule(View view) {
        //传统方式，组件间的相互调用
        startActivity(new Intent(MainActivity.this, OrderMainActivity.class));
    }

    public void toPersonalModule(View view) {
        startActivity(new Intent(MainActivity.this, PersonalMainActivity.class));
    }
```

这种方式的跳转，页面之间的耦合度比较高

**所以更好的方式是使用路由的方式来解决**



## APT & JavaPoet

APT(Annotation Processing Tool)即**注解处理器**，是一种用来处理注解的工具。JVM会在**编译期**就运行APT去扫描处理代码中的注解然后输出java文件。

`JavaPoet` is a Java API for generating `.java` source files.`JavaPoet` 可以用来生成`.java` 源文件



APT技术可以理解为：把自定义的注解，变成java代码，其中有两种方式：

+ 手动一行一行的写，如`EventBus`中的`EventBusAnnotationProcessor`

  ![019](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/019.png)

+ 通过使用JavaPoet，面向对象的思想进行编码



### annotation模块

创建annotation模块时，选择`Java or Kotlin Library`

![020](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/020.png)

创建`ARouter`注解

```java
@Target(ElementType.TYPE) //作用于类上
@Retention(RetentionPolicy.SOURCE) //编译期生效
public @interface ARouter {
    String path();

    String group() default ""; // 组
}
```

`build.gradle`文件内容

```groovy
plugins {
    id 'java-library'
}

// 控制台中文设置UTF-8（由于是编译期的输出，所以要指定一个UTF-8的编码）
tasks.withType(JavaCompile){
    options.encoding = "UTF-8"
}

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}
```



### annotation processor

创建`annotation_processor`模块，如下：

![021](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/021.png)



如下所示，创建`ARouterProcessor`类，生成`HelloWorld` java类：

```java
/**
 * 注解处理器
 */
@AutoService(Processor.class) //编译期绑定
@SupportedAnnotationTypes({"com.example.annotation.ARouter"}) //表示要处理哪个注解
@SupportedSourceVersion(SourceVersion.RELEASE_8) //支持的版本
public class ARouterProcessor extends AbstractProcessor {

    //需要的工具类
    private Filer filer;       // 文件管理工具类(java文件生成器)
    private Types typesTool;    // 类型处理工具类（类信息）
    private Elements elementsTool;  // Element处理工具类(函数、类、属性都是Element)
    private Messager messager; //编译期打印日志

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);

        elementsTool = processingEnv.getElementUtils();
        typesTool = processingEnv.getTypeUtils();
        filer = processingEnv.getFiler();
        messager = processingEnv.getMessager();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (annotations.size() == 0) {
            messager.printMessage(Diagnostic.Kind.NOTE, "没有发现被ARouter注解的类");
            return false; //false表示注解处理器没有工作
        }
        //获取被ARouter注解的类信息（有哪些类被ARouter注解）
        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(ARouter.class);
        for (Element element : elements) {
            //获取类节点，包节点
            PackageElement packageElement = elementsTool.getPackageOf(element);
            String packageName = packageElement.getSimpleName().toString();
            messager.printMessage(Diagnostic.Kind.NOTE, "packageName = " + packageName);
            //全类名
            String className = element.getSimpleName().toString();
            messager.printMessage(Diagnostic.Kind.NOTE, "被ARouter注解的类有：" + className);

            ARouter aRouter = element.getAnnotation(ARouter.class);
            //生成代码
            generateHelloWorld();
        }
        return false;
    }

    private void generateHelloWorld() {
        //JavaPoet
        MethodSpec main = MethodSpec.methodBuilder("main")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(void.class)
                .addParameter(String[].class, "args")
                .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")
                .build();

        TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(main)
                .build();

        JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld)
                .build();

        try {
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



> **AutoService**注解处理器是Google开发的，用来生成 **META-INF/services/javax.annotation.processing.Processor** 文件的，你只需要在你定义的注解处理器上添加 @AutoService(Processor.class) 就可以了，简直不能再方便了。



在`app`模块的`build.gradle`中添加`annotationProcessor`

![022](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/022.png)



build后，在build控制台中查看输出：

![023](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/023.png)



在`app`模块下的`build`文件夹中查看生成的类

![024](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/024.png)



































