# 可观察的数据对象

参考：

+ [使用可观察的数据对象](https://developer.android.com/topic/libraries/data-binding/observability)



在使用DataBinding的时候，有时会用到可观察的数据对象

> 可观察性是指一个对象将其数据变化告知其他对象的能力。通过数据绑定库，您可以让对象、字段或集合变为可观察。

> 任何 plain-old 对象都可用于数据绑定，但修改对象不会自动使界面更新。通过数据绑定，数据对象可在其数据发生更改时通知其他对象，即监听器。可观察类有三种不同类型：[对象](https://developer.android.com/topic/libraries/data-binding/observability#observable_objects)、[字段](https://developer.android.com/topic/libraries/data-binding/observability#observable_fields)和[集合](https://developer.android.com/topic/libraries/data-binding/observability#observable_collections)。

> 当其中一个可观察数据对象绑定到界面并且该数据对象的属性发生更改时，界面会自动更新。



## 相关类

### Observable

Observable是一个接口，定义如下：

```java
public interface Observable {

    /**
     * Adds a callback to listen for changes to the Observable.
     * @param callback The callback to start listening.
     */
    void addOnPropertyChangedCallback(OnPropertyChangedCallback callback);

    /**
     * Removes a callback from those listening for changes.
     * @param callback The callback that should stop listening.
     */
    void removeOnPropertyChangedCallback(OnPropertyChangedCallback callback);

    /**
     * The callback that is called by Observable when an observable property has changed.
     */
    abstract class OnPropertyChangedCallback {

        /**
         * Called by an Observable whenever an observable property changes.
         * @param sender The Observable that is changing.
         * @param propertyId The BR identifier of the property that has changed. The getter
         *                   for this property should be annotated with {@link Bindable}.
         */
        public abstract void onPropertyChanged(Observable sender, int propertyId);
    }
}
```



### BaseObservable

`BaseObservable`实现了`Observable`接口

```java
public class BaseObservable implements Observable {
    private transient PropertyChangeRegistry mCallbacks;

    public BaseObservable() {
    }

    @Override
    public void addOnPropertyChangedCallback(@NonNull OnPropertyChangedCallback callback) {
        synchronized (this) {
            if (mCallbacks == null) {
                mCallbacks = new PropertyChangeRegistry();
            }
        }
        mCallbacks.add(callback);
    }

    @Override
    public void removeOnPropertyChangedCallback(@NonNull OnPropertyChangedCallback callback) {
        synchronized (this) {
            if (mCallbacks == null) {
                return;
            }
        }
        mCallbacks.remove(callback);
    }

    /**
     * Notifies listeners that all properties of this instance have changed.
     */
    public void notifyChange() {
        synchronized (this) {
            if (mCallbacks == null) {
                return;
            }
        }
        mCallbacks.notifyCallbacks(this, 0, null);
    }

    /**
     * Notifies listeners that a specific property has changed. The getter for the property
     * that changes should be marked with {@link Bindable} to generate a field in
     * <code>BR</code> to be used as <code>fieldId</code>.
     *
     * @param fieldId The generated BR id for the Bindable field.
     */
    public void notifyPropertyChanged(int fieldId) {
        synchronized (this) {
            if (mCallbacks == null) {
                return;
            }
        }
        mCallbacks.notifyCallbacks(this, fieldId, null);
    }
}
```

其中添加了2个方法

+ `notifyChange`
+ `notifyPropertyChanged`



#### 继承BaseObservable

实现 `BaseObservable` 的数据类负责在属性更改时发出通知。具体操作过程是向 getter 分配 [`Bindable`](https://developer.android.com/reference/android/databinding/Bindable) 注解，然后在 setter 中调用 [`notifyPropertyChanged()`](https://developer.android.com/reference/android/databinding/BaseObservable#notifypropertychanged) 方法

```java
    private static class User extends BaseObservable {
        private String firstName;
        private String lastName;

        @Bindable
        public String getFirstName() {
            return this.firstName;
        }

        @Bindable
        public String getLastName() {
            return this.lastName;
        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
            notifyPropertyChanged(BR.firstName);
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
            notifyPropertyChanged(BR.lastName);
        }
    }
```

> 数据绑定在模块包中生成一个名为 `BR` 的类，该类包含用于数据绑定的资源的 ID。在编译期间，[`Bindable`](https://developer.android.com/reference/android/databinding/Bindable) 注释会在 `BR` 类文件中生成一个条目。如果数据类的基类无法更改，[`Observable`](https://developer.android.com/reference/android/databinding/Observable) 接口可以使用 [`PropertyChangeRegistry`](https://developer.android.com/reference/android/databinding/PropertyChangeRegistry) 对象实现，以便有效地注册和通知监听器。



### 可观察字段

可观察字段基本继承自`BaseObservableField`， `BaseObservableField`继承自`BaseObservable`

![061](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/061.png)

看下`ObservableInt`是怎样实现的

```java

/**
 * An observable class that holds a primitive int.
 * <p>
 * Observable field classes may be used instead of creating an Observable object. It can also
 * create a calculated field, depending on other fields:
 * <pre><code>public class MyDataObject {
 *     public final ObservableField&lt;String&gt; name = new ObservableField&lt;String&gt;();
 *     public final ObservableInt age = new ObservableInt();
 *     public final ObservableInt birthdayCount = new ObservableInt(age) {
 *         &#64;Override
 *         public int get() { return age.get() + 1; }
 *     };
 * }</code></pre>
 * Fields of this type should be declared final because bindings only detect changes in the
 * field's value, not of the field itself.
 * <p>
 * This class is parcelable and serializable but callbacks are ignored when the object is
 * parcelled / serialized. Unless you add custom callbacks, this will not be an issue because
 * data binding framework always re-registers callbacks when the view is bound. An parceled
 * ObservableInt will lose its dependencies.
 */
public class ObservableInt extends BaseObservableField implements Parcelable, Serializable {
    static final long serialVersionUID = 1L;
    private int mValue;

    /**
     * Creates an ObservableInt with the given initial value.
     *
     * @param value the initial value for the ObservableInt
     */
    public ObservableInt(int value) {
        mValue = value;
    }

    /**
     * Creates an ObservableInt with the initial value of <code>0</code>.
     */
    public ObservableInt() {
    }

    /**
     * Creates an ObservableInt that depends on {@code dependencies}. Typically,
     * {@link ObservableField}s are passed as dependencies. When any dependency
     * notifies changes, this ObservableInt also notifies a change.
     *
     * @param dependencies The Observables that this ObservableInt depends on.
     */
    public ObservableInt(Observable... dependencies) {
        super(dependencies);
    }

    /**
     * @return the stored value.
     */
    public int get() {
        return mValue;
    }

    /**
     * Set the stored value.
     *
     * @param value The new value
     */
    public void set(int value) {
        if (value != mValue) {
            mValue = value;
            notifyChange();
        }
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(mValue);
    }

    public static final Parcelable.Creator<ObservableInt> CREATOR
            = new Parcelable.Creator<ObservableInt>() {

        @Override
        public ObservableInt createFromParcel(Parcel source) {
            return new ObservableInt(source.readInt());
        }

        @Override
        public ObservableInt[] newArray(int size) {
            return new ObservableInt[size];
        }
    };
}

```

官方文档中的介绍

1.如需使用此机制，请采用 Java 编程语言创建 `public final` 属性，或在 Kotlin 中创建只读属性

```java
    private static class User {
        public final ObservableField<String> firstName = new ObservableField<>();
        public final ObservableField<String> lastName = new ObservableField<>();
        public final ObservableInt age = new ObservableInt();
    }
```

2.如需访问字段值，请使用 [`set()`](https://developer.android.com/reference/android/databinding/ObservableField#set) 和 [`get()`](https://developer.android.com/reference/android/databinding/ObservableField#get) 访问器方法

```java
    user.firstName.set("Google");
    int age = user.age.get();
```



### 可观察集合

#### Map

当键为引用类型（如 `String`）时，[`ObservableArrayMap`](https://developer.android.com/reference/android/databinding/ObservableArrayMap) 类非常有用

```java
    ObservableArrayMap<String, Object> user = new ObservableArrayMap<>();
    user.put("firstName", "Google");
    user.put("lastName", "Inc.");
    user.put("age", 17);
```

在xml中使用，可使用字符串键找到map

```xml
<data>
        <import type="android.databinding.ObservableMap"/>
        <variable name="user" type="ObservableMap<String, Object>"/>
    </data>
    …
    <TextView
        android:text="@{user.lastName}"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
    <TextView
        android:text="@{String.valueOf(1 + (Integer)user.age)}"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
    
```

#### List

当键为整数时，[`ObservableArrayList`](https://developer.android.com/reference/android/databinding/ObservableArrayList) 类非常有用，如下所示：

```java
    ObservableArrayList<Object> user = new ObservableArrayList<>();
    user.add("Google");
    user.add("Inc.");
    user.add(17);
```

在布局中，可通过索引访问列表，如以下示例所示：

```java
<data>
        <import type="android.databinding.ObservableList"/>
        <import type="com.example.my.app.Fields"/>
        <variable name="user" type="ObservableList<Object>"/>
    </data>
    …
    <TextView
        android:text='@{user[Fields.LAST_NAME]}'
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
    <TextView
        android:text='@{String.valueOf(1 + (Integer)user[Fields.AGE])}'
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
    
```



































