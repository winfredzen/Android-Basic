# 组件化-APT

内容来自：

+ [Android组件化实战（二）](https://www.bilibili.com/video/BV1X5411A7dc)



首先下了解**注解**：

+ [注解](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144)



APT教程：

+ [Android APT快速教程](https://juejin.cn/post/6844903696900292621)
+ [详细介绍编译时注解的使用方法](https://juejin.cn/post/6844903441215520775)



在上一节的例子中，页面之间的跳转，使用的是如下的方式：

```java
    public void toOrderModule(View view) {
        //传统方式，组件间的相互调用
        startActivity(new Intent(MainActivity.this, OrderMainActivity.class));
    }

    public void toPersonalModule(View view) {
        startActivity(new Intent(MainActivity.this, PersonalMainActivity.class));
    }
```

这种方式的跳转，页面之间的耦合度比较高

**所以更好的方式是使用路由的方式来解决**



## APT & JavaPoet

APT(Annotation Processing Tool)即**注解处理器**，是一种用来处理注解的工具。JVM会在**编译期**就运行APT去扫描处理代码中的注解然后输出java文件。

`JavaPoet` is a Java API for generating `.java` source files.`JavaPoet` 可以用来生成`.java` 源文件



APT技术可以理解为：把自定义的注解，变成java代码，其中有两种方式：

+ 手动一行一行的写，如`EventBus`中的`EventBusAnnotationProcessor`

  ![019](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/019.png)

+ 通过使用JavaPoet，面向对象的思想进行编码



### annotation模块

创建annotation模块时，选择`Java or Kotlin Library`

![020](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/020.png)

创建`ARouter`注解

```java
@Target(ElementType.TYPE) //作用于类上
@Retention(RetentionPolicy.SOURCE) //编译期生效
public @interface ARouter {
    String path();

    String group() default ""; // 组
}
```

`build.gradle`文件内容

```groovy
plugins {
    id 'java-library'
}

// 控制台中文设置UTF-8（由于是编译期的输出，所以要指定一个UTF-8的编码）
tasks.withType(JavaCompile){
    options.encoding = "UTF-8"
}

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}
```



### annotation processor

创建`annotation_processor`模块，如下：

![021](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/021.png)



如下所示，创建`ARouterProcessor`类，生成`HelloWorld` java类：

```java
/**
 * 注解处理器
 */
@AutoService(Processor.class) //编译期绑定
@SupportedAnnotationTypes({"com.example.annotation.ARouter"}) //表示要处理哪个注解
@SupportedSourceVersion(SourceVersion.RELEASE_8) //支持的版本
public class ARouterProcessor extends AbstractProcessor {

    //需要的工具类
    private Filer filer;       // 文件管理工具类(java文件生成器)
    private Types typesTool;    // 类型处理工具类（类信息）
    private Elements elementsTool;  // Element处理工具类(函数、类、属性都是Element)
    private Messager messager; //编译期打印日志

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);

        elementsTool = processingEnv.getElementUtils();
        typesTool = processingEnv.getTypeUtils();
        filer = processingEnv.getFiler();
        messager = processingEnv.getMessager();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (annotations.size() == 0) {
            messager.printMessage(Diagnostic.Kind.NOTE, "没有发现被ARouter注解的类");
            return false; //false表示注解处理器没有工作
        }
        //获取被ARouter注解的类信息（有哪些类被ARouter注解）
        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(ARouter.class);
        for (Element element : elements) {
            //获取类节点，包节点
            PackageElement packageElement = elementsTool.getPackageOf(element);
            String packageName = packageElement.getSimpleName().toString();
            messager.printMessage(Diagnostic.Kind.NOTE, "packageName = " + packageName);
            //全类名
            String className = element.getSimpleName().toString();
            messager.printMessage(Diagnostic.Kind.NOTE, "被ARouter注解的类有：" + className);

            ARouter aRouter = element.getAnnotation(ARouter.class);
            //生成代码
            generateHelloWorld();
        }
        return false;
    }

    private void generateHelloWorld() {
        //JavaPoet
        MethodSpec main = MethodSpec.methodBuilder("main")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(void.class)
                .addParameter(String[].class, "args")
                .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")
                .build();

        TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(main)
                .build();

        JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld)
                .build();

        try {
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



> **AutoService**注解处理器是Google开发的，用来生成 **META-INF/services/javax.annotation.processing.Processor** 文件的，你只需要在你定义的注解处理器上添加 @AutoService(Processor.class) 就可以了，简直不能再方便了。



在`app`模块的`build.gradle`中添加`annotationProcessor`

![022](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/022.png)



build后，在build控制台中查看输出：

![023](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/023.png)



在`app`模块下的`build`文件夹中查看生成的类

![024](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/024.png)



**不过我们目的是，写了`ARouter`后，把Activity路由到路由表中去**



## APT实现基于注解的View注入

实现基于注解的View，代替项目中的`findByView`。这里仅仅是学习怎么用APT，如果真的想用DI框架，推荐使用`ButterKnife`，功能全面。

> DI 依赖注入(Dependency Injection)

首先还是定义注解`DIView`和`DIActivity`

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DIView {
    int value() default 0;
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface DIActivity {

}
```

创建注解处理器，处理注解

```java

/**
 * 注解处理器
 */
@AutoService(Processor.class) //编译期绑定
public class DIProcessor extends AbstractProcessor {
    private Elements elementUtils;
    @Override
    public Set<String> getSupportedAnnotationTypes() {
        // 规定需要处理的注解
        return Collections.singleton(DIActivity.class.getCanonicalName());
    }
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        System.out.println("DIProcessor");
        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(DIActivity.class);
        for (Element element : elements) {
            // 判断是否Class
            TypeElement typeElement = (TypeElement) element;
            List<? extends Element> members = elementUtils.getAllMembers(typeElement);
            MethodSpec.Builder bindViewMethodSpecBuilder = MethodSpec.methodBuilder("bindView")
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                    .returns(TypeName.VOID)
                    .addParameter(ClassName.get(typeElement.asType()), "activity");
            for (Element item : members) {
                DIView diView = item.getAnnotation(DIView.class);
                if (diView == null){
                    continue;
                }
                bindViewMethodSpecBuilder.addStatement(String.format("activity.%s = (%s) activity.findViewById(%s)",item.getSimpleName(),ClassName.get(item.asType()).toString(),diView.value()));
            }
            TypeSpec typeSpec = TypeSpec.classBuilder("DI" + element.getSimpleName())
                    .superclass(TypeName.get(typeElement.asType()))
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                    .addMethod(bindViewMethodSpecBuilder.build())
                    .build();
            JavaFile javaFile = JavaFile.builder(getPackageName(typeElement), typeSpec).build();
            try {
                javaFile.writeTo(processingEnv.getFiler());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return true;
    }

    private String getPackageName(TypeElement type) {
        return elementUtils.getPackageOf(type).getQualifiedName().toString();
    }

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        elementUtils = processingEnv.getElementUtils();
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.RELEASE_7;
    }
}
```

在app模块的`MainActivity`中使用注解（注意要依赖模块）

```java
@DIActivity()
public class MainActivity extends AppCompatActivity {

    @DIView(value = R.id.text_view)
    TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        DIMainActivity.bindView(this);
        mTextView.setText("Hello, JavaPoet!");
    }
}
```

`build`后生成的`DIMainActivity`的代码如下：

![025](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/025.png)

最后页面的效果如下：

![026](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/026.png)



## JavaPoet常用方法总结

常用Element子类

1. TypeElement：类
2. ExecutableElement：成员方法
3. VariableElement：成员变量

通过包名和类名获取TypeName

```java
TypeName targetClassName = ClassName.get(“PackageName”, “ClassName”);
```

通过Element获取TypeName

```java
TypeName type = TypeName.get(element.asType());
```

获取TypeElement的包名

```java
String packageName = processingEnv.getElementUtils().getPackageOf(type).getQualifiedName().toString();
```

获取TypeElement的所有成员变量和成员方法

```java
List<? extends Element> members = processingEnv.getElementUtils().getAllMembers(typeElement);
```

















