# 组件化-路由

内容来自：

+ [Android组件化实战（三）](https://www.bilibili.com/video/BV1MK4y1m7cu)



## 公共依赖库的引入问题

可以在`app_config.gradle`中，定义好公共依赖库

```groovy
    // 定义依赖项目
    app_dependencies = [
            "okhttp": "com.squareup.okhttp3:okhttp:4.9.0",
            "constraintlayout": "androidx.constraintlayout:constraintlayout:2.0.4",
            "material": "com.google.android.material:material:1.3.0",
            "appcompat": "androidx.appcompat:appcompat:1.2.0",
            "junit": "junit:junit:4.+",
            "androidx_junit": "androidx.test.ext:junit:1.1.2",
            "espresso-core": "androidx.test.espresso:espresso-core:3.3.0"
            // ...
    ]
}
```

然后再在`common`模块的`build.gradle`中，引入

```groovy
    app_dependencies.each {k, v ->
        // api方式引入，其他模块在引入common时才会生效
        api v
        println('引入依赖: ' + k + " -> " + v)
    }
```



## 编译器传递参数

先在app模块下的 `build.gradle`中的`defaultConfig`中配置如下的内容：

![027](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/027.png)

然后在`annotation_processor`模块中，使用注解`@SupportedOptions`，传入key值

![028](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/028.png)

在`ARouterProcessor`的`init(ProcessingEnvironment processingEnv)`方法中获取编译器传递的参数

![029](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/029.png)

在`build`的时候，查看控制台输出

![030](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/images/030.png)























































