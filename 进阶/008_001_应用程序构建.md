# 应用程序构建

![034](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/034.png)

**什么是构建？**

构建，用一句话来总结，即“将源代码生成可执行应用程序的过程”

![035](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/035.png)

对应到Android开发领域中，构建即生成APK

**APK构建流程**

这个过程，涉及许多工具和流程。流程包括拷贝、编译、打包、签名、对齐、安装等；工具则包括 javac、kotlinc、d8、aapt2等…

![036](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/036.png)

通常来说有2中方式

1.打包人员一个一个执行命令行（开发人员需要了解整个流程）

2.编写脚本，把流程全部包含起来（脚本适配多个系统？Linux、MacOS）

开发领域引入了**构建工具**的概念，其定义为：一个可编程的工具，能够以 **可执行**和**有序** 的任务来表达满足需要的**自动化**过程。

Gradle基于jvm虚拟机（解决多平台），基于插件（可以分享）。Android官方有很多Gradle插件，如Run



**Gradle优势**：

- 无缝在各个平台运行
- 通过插件，提高构建逻辑复用能力，并具备强大的官方插件库
- 基于Groovy的DSL，提供[声明式](https://baike.baidu.com/item/声明式编程/9939512)的构建语言
- 构建流程定制能力强，可以基于插件、任务、生命周期等纬度进行定制



## Gralde基础

**生成Gradle Wrapper**

切换到项目的根目录，然后运行`gradle wrapper`

![037](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/037.png)



**Gradle的执行**

![038](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/038.png)



在Android Studio中的Terminal使用`./gradlew projects`，可能会提示`zsh: permission denied: ./gradlew`

![039](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/039.png)

可使用`chmod +x gradlew`命令后再使用



另外的一种方式是通过右上角Gradle窗口的 **Execute Gradle Task** 来执行

![040](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/040.png)



**升级降级Gradle**

1.直接修改工程根目录 `gradle/wrapper/gradle-wrapper.properties` 中的 `distributionUrl` 字段即可

2.使用命令如：

```shell
./gradlew wrapper --gradle-version 6.4
```



**快速上手**

在根目录下的`build.gradle`中添加一个打印的命令，如下：

![041](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/041.png)

执行`./gradlew clean -q`命令，有如下的打印

![042](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/042.png)





### Groovy语法

单行注释 //

多行注释 /* */

数据类型 byte short int long float double char

数据定义，如下的两种方式都行：

```groovy
int a = 10
def b = 10

println("a = $a")
println("b = $b")
```

字符串

```groovy
String str = "Hello, " + "World"
String str2 = str.toUpperCase()
println("str = $str2")
```

列表

```groovy
def array = [1, 2, 3, 4]
array.add(5)
//遍历
array.each {
    println("each item is $it")
}
println("array is $array")
```

映射表

```groovy
def map = ["name" : "mooc", "age" : "100"]

println("map is $map")
println("age is ${map["age"]}")
```



循环

```groovy
for (int i = 0; i < 10; i++) {
    println("age is $i")
}
```



方法的定义

```groovy
def hello(String name) {
    println("Hello, $name")
}
hello("wz")
```



DSL(Domain Specific Language) 领域专用语言

闭包，实现DSL

![043](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/043.png)

定义一个闭包

```groovy
// 打印一句话
def c = { println("Hello Closure")}
c()
```

有参数的闭包

```groovy
def c2 = {it -> println("c2: it = $it") }
c2("imooc")
```

有一个的参数的时候，参数可以忽略，默认名称为 `it`

```groovy
def c2 = {println("c2: it = $it") }
```

```groovy
// 只有一个参数的时候，名称可以任意指定，但是it就不可用了
def c3 = { name -> println("c3: name = $name") }
c3("imooc")
```

多个参数

```groovy
// 定义多个参数，需要用逗号分隔
def c4 = { name1, name2 ->
    println("c4: name1 = $name1")
    println("c4: name2 = $name2")
}
c4("imooc_1", "imooc_2")
```



例如，array的each遍历就是使用的闭包

```groovy
def list = [1, 3, 5, 7, 9]
list.each { println("item = $it") }
```



### 实现自定义DSL

如果要实现如下的类似的Android的DSL形式

```groovy
def myAndroid = {
    compileSdkVersion 27
    defaultConfig {
        versionName "1.0"
    }
}
```

定义两个类

```groovy
class DefaultConfig {

    private String versionName

    def versionName(String versionName) {
        this.versionName = versionName
    }

    @Override
    String toString() {
        return " DefaultConfig{ versionName = $versionName }"
    }

}

class Android {
    private int compileSdkVersion
    private DefaultConfig defaultConfig

    //构造方法
    Android() {
        this.defaultConfig = new DefaultConfig()
    }

    def compileSdkVersion(int compileSdkVersion) {
        this.compileSdkVersion = compileSdkVersion
    }

  	//接收的是闭包
    def defaultConfig(Closure closure) {
        // 将闭包与具体对象关联起来，关联后就获取到了同名的值了
        closure.setDelegate(defaultConfig)
        closure.call()
    }

    @Override
    String toString() {
        return "Android { compileSdkVersion = $compileSdkVersion, " +
                "defaultConfig = $defaultConfig}"
    }

}
```

使用DSL

```groovy
def myAndroid = {
    compileSdkVersion 27
    defaultConfig {
        versionName "1.0"
    }
}

Android a = new Android()
// 将闭包与具体对象关联起来
myAndroid.delegate = a
myAndroid.call()

println("myAndroid = $a")
```

输出结果如下：

> myAndroid = Android { compileSdkVersion = 27, defaultConfig =  DefaultConfig{ versionName = 1.0 }}



## Gradle构建脚本

任何一个标准的、基于Gradle构建工具的Android工程，都会涉及到下面几个重要的脚本：

- 根目录的`settings.gradle`：用来配置子工程列表。如果你利用 Android Studio 的 New Module 功能新建了一个子工程，就可以发现，工程目录下除了多出对应的子目录，`settings.gradle`文件中也会多出对应的内容，用于将该子工程纳入工程列表。
- 根目录的`build.gradle`：用来配置所有子工程**公用**的信息。例如maven仓库信息等。
- 各个子工程下的`build.gradle`：用于配置各个子工程各自的构建信息。如源码目录、第三方依赖等。
- 根目录`gradle.properties`：主要配置一些参数信息。如网络设置、Gradle执行过程中的JVM内存大小、以及一些构建脚本可以直接读取的版本号、名称等信息。



**构建的生命周期**

- 初始化阶段：收集需要参加本次构建的所有子工程，创建项目的层次结构，并且为每一个项目创建一个 [Project](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html) 实例。此阶段主要执行settings.gradle 脚本。
- 配置阶段：执行各个目录下build.gradle 脚本，完成Project对象的配置，并且根据项目自身的配置，构造出一个有向无环的任务依赖关系图，以便在下一个阶段执行。
- 执行阶段：负责将上一步生成的任务依赖图，依次执行。

在setting.build添加如下的生命周期监听

```groovy
include ':app'

println("[life-cycle] 我是settings.gradle")

//添加 构建的生命周期监听
gradle.addBuildListener(new BuildAdapter() {

    @Override
    void settingsEvaluated(Settings settings) {
        super.settingsEvaluated(settings)
        println("[life-cycle] 初始化阶段完成")
    }

    @Override
    void projectsEvaluated(Gradle gradle) {
        super.projectsEvaluated(gradle)
        println("[life-cycle] 配置阶段完成")
    }

    @Override
    void buildFinished(BuildResult buildResult) {
        super.buildFinished(buildResult)
        println("[life-cycle] 构建结束")
    }
})
```

在根目录下的build.gradle添加如下的打印内容

```groovy
println("[life-cycle] 我是根目录build.gradle")
```

在app目录下的build.gradle添加如下的打印内容

```groovy
println("[life-cycle] 我是app目录build.gradle")
```

如果build的话，输出内容的顺序如下：

![044](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/044.png)



在app目录下的build.gradle添加一个Task，如下：

```groovy
task testTask() {
    doLast {
        println("[life-cycle] 我是任务中的代码")
    }
}
```

终端执行`./gradlew :app:testTask -q`，输出结果如下：

![045](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/045.png)

**可见，是在配置阶段完成后，执行任务中的代码**



**重要的角色**

- rootProject：对应于当前**根工程**的抽象概念。从初始化阶段开始，我们在构建的任意一个阶段，都可以使用 rootProject对象。
- project：从配置阶段开始，每个工程都拥有一个对应的project实例，描述了当前工程的路径、所包含的任务、所使用的插件等信息。
- task：执行阶段实际上就是有序执行各个任务。



```groovy
println("[life-cycle] 我的工程路径：${rootProject.projectDir}")
```

输出结果为：`[life-cycle] 我的工程路径：/Users/wangzhen/Documents/GitHub/Android-Basic/进阶/code/gradle-basic`



在`projectsEvaluated`中获取子工程

![046](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/046.png)



在app的build.gralde中也可以获取它自己的工程路径

```groovy
println("[我是app project] 我的工程路径是${project.projectDir}")
```



Project其实是个接口

![047](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/047.png)



**Gradle任务**

Task是Gradle中的最小执行单元，我们所有的构建行为，编译、签名、打包等都是执行了某一个Task。一个project可以有多个Task，Task之间可以互相依赖。

对于构建流程的定制，基本上是围绕Task去展开，例如，可以通过给 `assembleDebug` 任务添加一个`doLast` 动作，在构建结束后执行一些自定义行为（如将生成的APK拷贝到指定目录等）。

任务的学习，主要关注以下三方面：

- 任务的定义
- 任务的执行
- 任务的依赖



任务的执行：`./gradlew clean`

clean任务是定义在根目录下的`build.gradle`中的

```groovy
task clean(type: Delete) {
    delete rootProject.buildDir
}
```



创建任务

![048](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/048.png)

![049](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/049.png)



任务的依赖

使用dependOn

![050](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/050.png)

















