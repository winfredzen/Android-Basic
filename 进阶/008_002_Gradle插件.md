# Gradle插件

想象Gradle是一个平台，具体的构建功能实际上是由 **Gradle 插件**提供的，例如 APK构建、Java代码编译等。

Plugin负责封装、管理并提供Gradle运行期间需要的Task。在工程中依赖某个插件，就能够复用这个插件提供的构建行为。各位平时在工程脚本中所看到的 `apply plugin 'com.android.application'` 、 `apply plugin 'kotlin-android'` ，都是在使用插件去拓展自己工程的构建能力。

可以看到，使用插件可以将代码进行 **模块化** 封装，进而提升功能的 **复用** 能力。

主要有两种类型

- 二进制插件 ***（binary plugins）***
- 脚本插件 ***（script plugins）***

开发者应该根据不同的使用场景，来选择不同的插件形式。二进制插件通常会被发布成复用能力更强的jar包等，可供不同项目工程、不同开发人员之间 **共用** 同一套构建逻辑，常见的Android、Kotlin插件等，这些都属于二进制插件。

脚本插件更多用于对 **当前工程** 的构建逻辑进行配置和拓展，如hook某些任务，做一些构建前后的拷贝、清理工作等。

二者其实可以理解成一个 递进 的关系。由于脚本插件的编写与使用成本较低，一开始通常会使用该类型（除非明确知道功能会被共享复用），若后续代码量变大或者功能需要考虑共享了，那么再考虑包装成二进制插件也是完全没有问题的。



**二进制插件** 

1.声明插件ID与版本号

![051](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/051.png)

2.apply 使用插件，在app子工程的build.gradle

```groovy
// 应用插件
apply plugin: 'com.android.application'
```

3.对插件配置，如：

```groovy
// 配置Android插件所需参数
android {
    compileSdkVersion 29
    buildToolsVersion "29.0.2"
    defaultConfig {
        applicationId "com.imooc.gradle.lifecycle"
        minSdkVersion 15
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(
                    'proguard-android-optimize.txt'),
                    'proguard-rules.pro'
        }
    }
}
```



**脚本插件**

跟目录下，新建一个`other.gradle`

在app中的build.gradle，中引入

```groovy
apply from: project.rootProject.file("other.gradle")
```



## 开发Gradle插件

二进制插件的[开发形式](https://docs.gradle.org/current/userguide/custom_plugins.html#custom_plugins)，可以进一步细分为两种：

- 独立工程 ***（standalone project）***
- buildSrc 工程 ***(buildSrc project)***

顾名思义，独立工程意味着我们需要创建一个独立于日常工作项目的新工程，去开发插件的逻辑。这种开发方式的问题在于，如果需要调试功能，需要将其先打包为jar包-在工作项目中引用-编译测试，整个开发链路比较麻烦而复杂。



**二进制插件开发的步骤**

1.建立插件工程 - 插件的入口

2.实现插件内部逻辑

3.发布与使用插件



更推荐的是采用 buildSrc 的形式，这个工程可以直接嵌入在我们日常的工作项目中。具体形式如下：

```tex
.
├── buildSrc
│   ├── build.gradle
│   └── src
│       └── main
│            └── groovy
│                  └── com
│                    └── enterprise
│                      └── XxxPlugin.groovy
├── settings.gradle
├── subprojecto-one
│   └── build.gradle 
└── subproject-two
    └── build.gradle 

```



任意一个时刻修改了插件内部逻辑，只需要重新触发构建，Gradle就会自动将buildSrc进行编译，生成一个jar包供项目中的其他子工程引用。这对于开发者来说是非常方便的，不需要反复重新打包、引用。



### 页面路由

![052](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/052.png)

![053](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/053.png)

前4个都需要在编译期间完成



### 新建插件

1.在根目录下新建`buildSrc`目录，新建目录`src/main/groovy`，在新建package，为`com/imooc/router/gradle`

2.新建`resources`目录

目录结构如下：

![054](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/054.png)



`RouterPlugin.groovy`内容

```groovy
package com.imooc.router.gradle

import org.gradle.api.Plugin
import org.gradle.api.Project

class RouterPlugin implements Plugin<Project> {

    //实现apply方法，注入插件的逻辑
    @Override
    void apply(Project project) {
        println("I am from RouterPlugin, apply from ${project.name}")
    }
}
```

`com.imooc.router.properties`内容

```tex
implementation-class=com.imooc.router.gradle.RouterPlugin
```



3.在app模块的build.gradle中引用插件

![055](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/055.png)

build时就有输出了

![056](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/056.png)



### 实现参数配置

什么是参数配置？如app模块下的`android {}`即为参数配置

1.定义Extension

```groovy
package com.imooc.router.gradle

class RouterExtension {
    //保存生成文档的路径
    String wikiDir
}
```

2.注册Extension

3.使用Extension

4.获取Extension

![057](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/057.png)

app的`build.gradle`中使用`router`配置

![058](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/058.png)

使用`./gradlew clean -q`命令，输出结果如下：

![059](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/059.png)











