# APT

APT Annotation Processing Tool 注解处理器

Java注解（Annotation），又可称为Java标注。它是一种**注释机制**，用于对类、方法、变量、参数和包等进行标注

> 注解，是**给编译器看的**。编译器可以在编译过程中，将注解里面的信息收集起来，在编译过程中处理，或者是嵌入到最终字节码中，Java虚拟机在加载类的同时会加载这些注解的内容，供程序在运行时获取。
>
> 按照注解的生命周期（使用 `@Retention` 指定）不同，注解主要可以分为下面几种：
>
> - ***SOURCE：*** 只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里；
> - ***CLASS：*** 注解在class文件中可用，但会被JVM丢弃。该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中。这也是默认的生命周期；
> - ***RUNTIME：*** 注解信息将在运行期（Java虚拟机加载之后）也保留，因此可以通过反射机制读取注解的信息。



**工作原理**

注解只是信息、标注，需要对信息进行处理，才能发挥其作用，因此牵涉出了注解处理这个过程。编译器可以帮助我们收集注解，但是处理逻辑还是需要开发者自行指定。

![067](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/067.jpeg)

+ **注解工程：** 用于声明自定义注解
+ **注解处理器工程：** 依赖注解工程，实现注解处理器，并通过META-INF中的配置，指定对应的实现类，供Java编译器查找。

+ **Android工程：** 即我们的日常工程，需要依赖上述两者。在使用注解后，还要在第三方依赖中声明上述注解处理器，告知Java编译器需帮助我们收集注解并回调给该注解处理器。



**开发流程**

![068](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/068.png)

![069](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/069.png)



## 建立注解

### 定义注解

**建立注解工程**

1.File->New->Directory，命名为`router-annotations`

2.在`router-annotations`中新建`build.gradle`

```groovy
// 应用java插件
apply plugin: 'java'

// 设置源码兼容性
targetCompatibility = JavaVersion.VERSION_1_7
sourceCompatibility = JavaVersion.VERSION_1_7
```

3.`settings.gradle`中引入

```groovy
include ':router-annotations'
```

4.在`router-annotations`新建源码目录

![070](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/070.png)

5.定义注解`Destination`

```java
/**
 * 说明当前注解可以修饰的元素，此处表示可以用于标记在类上面
 */
@Target({ElementType.TYPE})
/**
 * 说明当前注解可以被保留的时间
 */
@Retention(RetentionPolicy.CLASS)
public @interface Destination {

    /**
     * 当前页面的URL，不能为空
     * @return 页面URL
     */
    String url();

    /**
     * 对于当前页面的中文描述
     * @return 例如 "个人主页"
     */
    String description();
}
```

6.app依赖`router-annotations`

```groovy
implementation project(':router-annotations')
```



### 使用注解

```java
@Destination(
        url = "router://page-home",
        description = "应用主页"
)
public class MainActivity extends Activity
```



## 注解处理器

### 建立注解处理器工程

1.新建`router-processor`模块，步骤与上面类似

2.新建`build.gradle`文件

```groovy
// 引入java插件，帮助编译代码
apply plugin: 'java'

dependencies {
    implementation project(':router-annotations')
    implementation 'com.google.auto.service:auto-service:1.0-rc6'
    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'
    implementation 'com.google.code.gson:gson:2.8.1'
}
```

3.src，包结构

![071](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/071.png)

4.新建`DestinationProcessor`类，继承自`AbstractProcessor`

实现方法

1.`getSupportedAnnotationTypes`

```java
    /**
     * 告诉编译器，当前处理器支持的注解类型
     * @return
     */
    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Collections.singleton(
                Destination.class.getCanonicalName()
        );
    }
```

2.`process`

```java
    /**
     * 编译器找到我们关心的注解后，会回调这个方法
     * @param set
     * @param roundEnvironment
     * @return
     */
    @Override
    public boolean process(Set<? extends TypeElement> set,
                           RoundEnvironment roundEnvironment) {
```



## 采集注解

见代码，在`DestinationProcessor`处理



## 注册注解处理器

使用Google提供的AutoService库

`router-processor`库的build.gradle中引入AutoService

![076](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/076.png)

声明AutoService注解

![077](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/077.png)

具体的参考代码，我在实践中遇到一些问题

1.`./gradlew :app:assembleDebug -q`后有错误提示

```txt
java.lang.UnsupportedClassVersionError: com/imooc/router/processor/DestinationProcessor has been compiled by a more recent version of the Java Runtime (class file version 59.0), this version of the Java Runtime only recognizes class file versions up to 55.0
```

可在当前模块下的build.gradle中添加，java版本

```groovy
java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}
```

2.`System.out.println`的日志一致打印不出来

可使用`javax.annotation.processing.Messager` ，在编译期打印日志

```java
messager.printMessage(Diagnostic.Kind.WARNING, " >>> process start ...");
```

![078](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/078.png)



查看生成的的类，位置如下，`@AutoService(Processor.class)`自动注册了注解处理器：

![079](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/079.png)





## 生成类-类信息拼接

期望中自动生成的一个类的信息如下：

![080](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/080.png)

实际生成的类

![081](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/081.png)



生成代码的位置，如果没啥用kapt，则是在app模块下的`build/generated/ap_generated_sources`

如果使用了kapt，则位于`build/generated/source/kapt`

如下：

![082](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/082.png)



而且生成的类，也打包在了apk中

![083](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/083.png)



## 发布与使用

使用maven发布，定义一个`maven-publish.gradle`文件

每个moudle下都包含一个`gradle.properties`，里面定义`ARTIFACT_ID`

```groovy
POM_ARTIFACT_ID=router-processor
```

具体的参考`maven-publish.gradle`代码



```groovy
// 使用maven插件中的发布功能
apply plugin: 'maven'

// 读取工程的配置
Properties gradleProperties = new Properties()
gradleProperties.load(
        project.rootProject.file('gradle.properties').newDataInputStream())

//读取工程配置
def VERSION_NAME = gradleProperties.getProperty("VERSION_NAME")
//发布的位置
def POM_URL = gradleProperties.getProperty("POM_URL")
def GROUP_ID = gradleProperties.getProperty("GROUP_ID")

//当前工程的文件
Properties projectGradleProperties = new Properties()
projectGradleProperties.load(
        project.file('gradle.properties').newDataInputStream()
)

def POM_ARTIFACT_ID = projectGradleProperties.getProperty("POM_ARTIFACT_ID")

println("maven-publish VERSION_NAME = $VERSION_NAME")
println("maven-publish POM_URL = $POM_URL")
println("maven-publish GROUP_ID = $GROUP_ID")
println("maven-publish POM_ARTIFACT_ID = $POM_ARTIFACT_ID")

uploadArchives {
    repositories {
        mavenDeployer {

            // 填入发布信息
            repository(url: uri(POM_URL)) {
                pom.groupId = GROUP_ID
                pom.artifactId = POM_ARTIFACT_ID
                pom.version = VERSION_NAME
            }

            pom.whenConfigured { pom ->
                pom.dependencies.forEach { dep ->

                    if (dep.getVersion() == "unspecified") {
                        dep.setGroupId(GROUP_ID)
                        dep.setVersion(VERSION_NAME)
                    }

                }
            }


        }
    }
}

```



1.先调用`./gradlew clean`

2.再调用`./gradlew :router-annotations:uploadArchives`，发布`router-annotations`

3.再调用`./gradlew :router-processor:uploadArchives`，发布`router-processor`

![084](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/084.png)



在app模块的build.gradle中引入进来，使用

![085](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/085.png)





## 思考

1.页面路由框架如何支持参数自动注入？

参考：

+ [组件化-路由](https://github.com/winfredzen/Android-Basic/blob/master/%E6%9E%B6%E6%9E%84/007_%E7%BB%84%E4%BB%B6%E5%8C%96-%E8%B7%AF%E7%94%B1.md)



2.页面路由框架如何支持前置逻辑处理？

可以考虑AOP的思想



3.页面路由框架如何支持打开更多页面类型？

可以考虑将打开页面的具体行为进行接口化抽象，然后预置或者由使用者自行定义实现。



## 生成文档

页面路由框架自动生成文档

![086](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/086.png)

在模块化开发的过程中，页面分散在不同的模块中

### 传递路径参数

`annotationProcessor`处理java可以，但是项目中使用kotlin+java的话，就需要使用kapt

```groovy
kapt project(':router-processor')
```

在app模块的下的`build.gradle`传入路径（需要在gradle中通过kapt提供的`arguments`配置传递进去。）

![087](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/087.png)



在`DestinationProcessor`中获取

![088](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/088.png)



### 生成Json文件

在json文件中保存页面映射信息

文件路径是上面传递过来的路径

![089](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/089.png)













