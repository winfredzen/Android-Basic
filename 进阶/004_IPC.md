# IPC

Linux跨进程通信方式

+ 管道
+ 消息队列
+ 信号
+ 共享内存
+ 信号量
+ 套接字

IPC全称是`Inter-Process Communication`，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程

IPC中的一些基本概念：

+ Serializable接口
+ Parcelable接口
+ Binder

## 序列化

为什么要序列化？

+ 永久性保存对象，保存对象的字节序列到本地文件中
+ 通过序列化对象在网络中传递对象
+ 通过序列化在进程间传递对象

> Android中实现序列化有两个选择：一是实现`Serializable`接口（是JavaSE本身就支持的），一是实现`Parcelable`接口（是Android特有功能，效率比实现`Serializable`接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现`Parcelable`接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。
> 
> 注：Android中`Intent`传递对象有两种方法：一是`Bundle.putSerializable(Key，Object)`，另一种是`Bundle.putParcelable(Key，Object)`。当然这些Object是有一定的条件的，前者是实现了`Serializable`接口，而后者是实现了`Parcelable`接口。

参考：

+ [详细介绍Android中Parcelable的原理和使用方法](https://www.jianshu.com/p/32a2ec8f35ae)

## Binder

Binder是Android中的一个类，实现了IBinder接口

```java
public class Binder extends Object implements IBinder
```

> + 从IPC角度来说，Binder是Android中的一种跨进程通信方式
> + 从Android Framework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager等等)和相应的ManagerService的桥梁
> + 从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端的服务或者数据，这里的服务包括普通服务和基于AIDL的服务

**Binder架构**

![013](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/013.png)

> + AIDL提供对外的接口和实现
> + 通过AIDL文件调用到java层
> + 通过java的jni调用到底层

![014](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/014.png)

**创建AIDL文件**

![010](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/010.png)

创建后，会在`main`目录下，多出一个`aidl`目录，包名与`java`目录下的相同

![011](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/011.png)

Service参考文档：

+ [Android Service完全解析，关于服务你所需知道的一切(上)](https://blog.csdn.net/guolin_blog/article/details/11952435)
+ [Android Service完全解析，关于服务你所需知道的一切(下)](https://blog.csdn.net/guolin_blog/article/details/9797169)

其它[Android IPC 之Service 还可以这么理解](https://www.jianshu.com/p/f5e08b06bf7a)

### AIDL

参考：[Android Service完全解析，关于服务你所需知道的一切(下)](https://blog.csdn.net/guolin_blog/article/details/9797169)

> **AIDL（Android Interface Definition Language）**是Android接口定义语言的意思，它可以用于让某个Service与多个应用程序组件之间进行**跨进程通信**，从而可以实现多个应用程序共享同一个Service的功能。

AIDL是基于Binder的，是Android提供的一种基于Binder，更为方便的实现IPC通信的方式

+ 定义IPC过程中接口的一种描述语言
+ AIDL文件在编译过程中生成接口的实现类，用于IPC通信
+ 支持基本的类型，实现Parcelable接口的对象，List、Map

Demo教程：

+ [Android实现跨进程通信](https://www.imooc.com/learn/1195)

#### 连接服务通过AIDL进行IPC

创建一个`IConnectionService.aidl`文件

![015](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/015.png)

编译后，会生成`IConnectionService` java文件

![016](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/016.png)

创建`RemoteService`服务

![023](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/023.png)

在`AndroidManifest.xml`文件中注册，注意`android:process=":remote"`

```xml
<service android:name=".RemoteService" android:process=":remote" />
```

运行时会有如下的2个进程

![024](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/024.png)

#### 遇到的问题

##### 1.线程的问题

如下在`disconnect`中弹出一个Toast，在实际开发中出现如下的错误

![018](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/018.png)

![017](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/017.png)

从输出log也可以看到，当前的输出不是在主线程

```java
2021-08-31 15:38:42.958 18521-18544/com.example.ipcdemo D/RemoteService: thread name = Binder:18521_3
```

修改成如下的形式：

![019](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/019.png)

![020](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/020.png)

##### 2.阻塞的问题

由于`RemoteService`中的`connect()`阻塞了5s，我们在使用`connectionServiceProxy.connect();`方法调用这个方法时，会发现调用处也要被阻塞5s，在界面显示上看，button也一值处于被按下的状态，直至5s后才恢复

![021](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/021.png)

怎么解决呢？**使用oneway**

> `oneway` 关键字用于修改远程调用的行为。使用此关键字后，**远程调用不会屏蔽**，**而只是发送事务数据并立即返回**。最终接收该数据时，接口的实现会将其视为来自 `Binder` 线程池的常规调用（普通的远程调用）。如果 `oneway` 用于本地调用，则不会有任何影响，且调用仍为同步调用。
> 
> 注意使用`oneway`后，方法不能有返回值，否则编译会出错
> 
> ![022](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/022.png)

#### 消息服务通过AIDL进行IPC通信

1.首先定义实体类，例如位于`com.example.ipcdemo.entity`包下的`Message`类，实现`Parcelable`接口

![025](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/025.png)

2.在AIDL中直接引用源码中的实体类是没法直接引用到的，需要定义对应Message的AIDL文件

注意`Message`类是在`com.example.ipcdemo.entity`下，通知AIDL文件也需要在系统的路径下

![026](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/026.png)

```java
package com.example.ipcdemo.entity;

parcelable Message;
```

这样AIDL中的文件和源码中的文件就进行了关联

3.创建`IMessageService.aidl`文件

> 1.**注意导包**：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，**就算目标文件与当前正在编写的 .aidl 文件在同一个包下**
> 
> 2.自己定义的类型，不是基本类型的话，需要关键字，否则出错
> 
> ![027](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/027.png)

#### in，out，inout

其它可参考：

+ [你真的理解AIDL中的in，out，inout么？](https://blog.csdn.net/luoyanglizi/article/details/51958091)

**所有的非基本参数都需要一个定向tag来指出数据流通的方式，不管是 in , out , 还是 inout 。基本参数的定向tag默认是并且只能是 in **

**in 为定向 tag 的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；**

**out 的话表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；**

**inout 为定向 tag 的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。**

在例子中，将`in`关键字，修改为`inout`关键字后，build会出现如下的错误

![028](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/028.png)

此时`Message`类需要实现`readFromParcel(Parcel parcel)`方法

![029](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/029.png)

### Messenger

+ 基于Handler、Message实现
+ 不支持并发的通信，只支持串行实时通信
+ 传输Bundle支持的数据类型

Messenger继承自Object，实现了[Parcelable](https://developer.android.com/reference/android/os/Parcelable)接口，官方文档的说明：

> Reference to a Handler, which others can use to send messages to it. This allows for the implementation of message-based communication across processes, by creating a Messenger pointing to a Handler in one process, and handing that Messenger to another process.
> 
> Note: the implementation underneath is just a simple wrapper around a `Binder` that is used to perform the communication. This means semantically you should treat it as such: this class does not impact process lifecycle management (you must be using some higher-level component to tell the system that your process needs to continue running), the connection will break if your process goes away for any reason, etc.

> 对 Handler 的引用，其他人可以使用它来向它发送消息。 这允许跨进程实现基于消息的通信，方法是创建一个指向一个进程中的处理程序的 Messenger，并将该 Messenger 交给另一个进程。
> 
> 注意：底层的实现只是一个用于执行通信的 `Binder` 的简单包装器。 这意味着在语义上你应该这样对待它：这个类不会影响进程生命周期管理（你必须使用一些更高级别的组件来告诉系统你的进程需要继续运行），如果你的进程消失，连接将中断 出于任何原因等。

一般的使用方式，如下：

```java
private Messenger messengerProxy;
```

```java
                try {
                    Message message = new Message();
                    message.setContent("send message from main by messenger");

                    android.os.Message data = new android.os.Message();
                    //提供给服务端reply
                    data.replyTo = clientMessenger;
                    Bundle bundle = new Bundle();
                    bundle.putParcelable("message", message);
                    data.setData(bundle);
                    messengerProxy.send(data);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
```

## 源码

源码地址：

+ [ipcdemo](https://github.com/winfredzen/Android-Basic/tree/master/other/code/ipcdemo)



2个客户端使用AIDL进行通讯，可参考：

+ [使用AIDL实现两个APP之间跨进程通信](https://juejin.cn/post/6844903887539814407)

代码位置[**AIDL-master**]([Android-Basic/进阶/code/AIDL-master at master · winfredzen/Android-Basic · GitHub](https://github.com/winfredzen/Android-Basic/tree/master/%E8%BF%9B%E9%98%B6/code/AIDL-master))








