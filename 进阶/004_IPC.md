# IPC

Linux跨进程通信方式

+ 管道
+ 消息队列
+ 信号
+ 共享内存
+ 信号量
+ 套接字



IPC全称是`Inter-Process Communication`，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程



IPC中的一些基本概念：

+ Serializable接口
+ Parcelable接口
+ Binder



## 序列化

为什么要序列化？

+ 永久性保存对象，保存对象的字节序列到本地文件中
+ 通过序列化对象在网络中传递对象
+ 通过序列化在进程间传递对象

> Android中实现序列化有两个选择：一是实现`Serializable`接口（是JavaSE本身就支持的），一是实现`Parcelable`接口（是Android特有功能，效率比实现`Serializable`接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。实现Serializable接口非常简单，声明一下就可以了，而实现`Parcelable`接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。
>
> 注：Android中`Intent`传递对象有两种方法：一是`Bundle.putSerializable(Key，Object)`，另一种是`Bundle.putParcelable(Key，Object)`。当然这些Object是有一定的条件的，前者是实现了`Serializable`接口，而后者是实现了`Parcelable`接口。

参考：

+ [详细介绍Android中Parcelable的原理和使用方法](https://www.jianshu.com/p/32a2ec8f35ae)



## Binder

Binder是Android中的一个类，实现了IBinder接口

```java
public class Binder extends Object implements IBinder
```

> + 从IPC角度来说，Binder是Android中的一种跨进程通信方式
> + 从Android Framework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager等等)和相应的ManagerService的桥梁
> + 从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端的服务或者数据，这里的服务包括普通服务和基于AIDL的服务



**Binder架构**

![013](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/013.png)

> + AIDL提供对外的接口和实现
> + 通过AIDL文件调用到java层
> + 通过java的jni调用到底层

![014](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/014.png)



**创建AIDL文件**

![010](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/010.png)

创建后，会在`main`目录下，多出一个`aidl`目录，包名与`java`目录下的相同

![011](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/011.png)

Service参考文档：

+ [Android Service完全解析，关于服务你所需知道的一切(上)](https://blog.csdn.net/guolin_blog/article/details/11952435)
+ [Android Service完全解析，关于服务你所需知道的一切(下)](https://blog.csdn.net/guolin_blog/article/details/9797169)



其它[Android IPC 之Service 还可以这么理解](https://www.jianshu.com/p/f5e08b06bf7a)



### AIDL

参考：[Android Service完全解析，关于服务你所需知道的一切(下)](https://blog.csdn.net/guolin_blog/article/details/9797169)



> **AIDL（Android Interface Definition Language）**是Android接口定义语言的意思，它可以用于让某个Service与多个应用程序组件之间进行**跨进程通信**，从而可以实现多个应用程序共享同一个Service的功能。

AIDL是基于Binder的，是Android提供的一种基于Binder，更为方便的实现IPC通信的方式

+ 定义IPC过程中接口的一种描述语言
+ AIDL文件在编译过程中生成接口的实现类，用于IPC通信
+ 支持基本的类型，实现Parcelable接口的对象，List、Map



Demo教程：

+ [Android实现跨进程通信](https://www.imooc.com/learn/1195)



#### 连接服务通过AIDL进行IPC



创建一个`IConnectionService.aidl`文件

![015](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/015.png)

编译后，会生成`IConnectionService` java文件

![016](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/016.png)



创建`RemoteService`服务

![023](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/023.png)

在`AndroidManifest.xml`文件中注册，注意`android:process=":remote"`

```xml
<service android:name=".RemoteService" android:process=":remote" />
```

运行时会有如下的2个进程

![024](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/024.png)



#### 遇到的问题

##### 1.线程的问题

如下在`disconnect`中弹出一个Toast，在实际开发中出现如下的错误

![018](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/018.png)

![017](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/017.png)

从输出log也可以看到，当前的输出不是在主线程

```java
2021-08-31 15:38:42.958 18521-18544/com.example.ipcdemo D/RemoteService: thread name = Binder:18521_3
```

修改成如下的形式：

![019](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/019.png)

![020](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/020.png)



##### 2.阻塞的问题

由于`RemoteService`中的`connect()`阻塞了5s，我们在使用`connectionServiceProxy.connect();`方法调用这个方法时，会发现调用处也要被阻塞5s，在界面显示上看，button也一值处于被按下的状态，直至5s后才恢复

![021](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/021.png)

怎么解决呢？**使用oneway**

> `oneway` 关键字用于修改远程调用的行为。使用此关键字后，**远程调用不会屏蔽**，**而只是发送事务数据并立即返回**。最终接收该数据时，接口的实现会将其视为来自 `Binder` 线程池的常规调用（普通的远程调用）。如果 `oneway` 用于本地调用，则不会有任何影响，且调用仍为同步调用。
>
> 注意使用`oneway`后，方法不能有返回值，否则编译会出错
>
> ![022](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/022.png)



#### 消息服务通过AIDL进行IPC通信

1.首先定义实体类，例如位于`com.example.ipcdemo.entity`包下的`Message`类，实现`Parcelable`接口

![025](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/025.png)

2.在AIDL中直接引用源码中的实体类是没法直接引用到的，需要定义对应Message的AIDL文件

注意`Message`类是在`com.example.ipcdemo.entity`下，通知AIDL文件也需要在系统的路径下

![026](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/026.png)

```java
package com.example.ipcdemo.entity;

parcelable Message;
```

这样AIDL中的文件和源码中的文件就进行了关联



3.创建`IMessageService.aidl`文件

> 1.**注意导包**：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，**就算目标文件与当前正在编写的 .aidl 文件在同一个包下**
>
> 2.自己定义的类型，不是基本类型的话，需要关键字，否则出错
>
> ![027](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/027.png)







##### 源码

源码地址：

+ [ipcdemo](https://github.com/winfredzen/Android-Basic/tree/master/other/code/ipcdemo)



### Messenger

+ 基于Handler、Message实现
+ 不支持并发的通信，只支持串行实时通信
+ 传输Bundle支持的数据类型



















