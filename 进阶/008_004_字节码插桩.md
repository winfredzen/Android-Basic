# 字节码插桩

对于大部分开发者而言，绝大多数的工作时间基本是在**编写源代码**。构建阶段，工具会将源代码编译生成**字节码文件**，然后汇总生成**dex文件**并打包到最终APK中。在这两个阶段，其实都可以去进行干预，实现一些自动化的流程，这也是很多知名第三方框架的思想。

![093](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/093.jpeg)

在源码被编译为字节码文件的过程中，可以利用前面课程内容介绍到的编译时注解处理技术，让程序帮我们**自动生成代码**。

字节码文件被编译为dex文件的阶段，可以利用**字节码处理技术**（也可称为字节码插桩技术），对字节码文件进行**修改、插入、替换、删除、生成**等操作。注意，由于在这个阶段可以汇总获取到**所有**即将被打包到安装包的类，因此可以更为**全面**地对代码进行一些**统一处理**。

举一个应用场景，在实现数据打点（亦可称为数据埋点、数据采集）组件的时候，通常要收集用户的**点击事件**。为了能实现**非侵入式**的采集，可采用面向切面编程（AOP）的思想，自动向字节码中所有的 onClick 方法中插入一段采集代码，即可实现开发者无感知的采集逻辑。

这个技术还有很多应用场景，而且也不局限于Android开发领域。

在Android中实现字节码插桩技术，主要关注两方面：

- 需要找好处理时机
- 进行字节码处理

什么是恰当的处理时机？即 **全部的字节码文件已经生成好，准备启动dex编译流程** 的这个间隙。

利用我们前面学习的Gradle知识，可以先找到dex对应的**任务**，然后在该任务开始前（ `doFirst` ），进行字节码处理。不过幸运的是，Android官方已经提供了[Transform API](https://google.github.io/android-gradle-dsl/javadoc/3.4/com/android/build/api/transform/Transform.html)，各位可将其理解成一个**回调接口**，恰好就是在上述时机进行回调的。

开发者只需要向构建流程**注册**这样一个回调接口，即可在对应的流程里，接收到所有字节码文件，从而进行自定义的字节码处理逻辑。

另外一个需要关注的问题是，如何对字节码进行处理？字节码文件是具有[固定格式](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)的二进制文件，我们可以按照其内部格式，去解析读取对应的信息。这确实可以达到目的，不过工作量会比较大。

![094](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/094.jpeg)

这个时候可以采用一些字节码处理工具，辅助我们的工作。常用的有[ASM](https://asm.ow2.io/)、[AspectJ](https://www.baeldung.com/aspectj)等。



考虑这样的使用场景，统建方法的执行时间，如果需要统计的方法比较多，就需要使用自动化的方式实现。此时就可以考虑使用字节码插桩，修改字节码

![095](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/095.png)

ASM可以用来解析、修改、生成class文件



在上一节的例子中，已经生成了映射文件，如`RouterMapping_1649595789883`：

```java
public class RouterMapping_1649595789883 {

    public static Map<String, String> get() {

        Map<String, String> mapping = new HashMap<>();

        mapping.put("router://page-home", "com.imooc.router.demo.MainActivity");
        mapping.put("router://imooc/profile", "com.imooc.router.demo.ProfileActivity");
        mapping.put("router://page-kotlin", "com.imooc.router.demo.KtMainActivity");
        return mapping;
    }
}
```

但在实际的工程中，会有很多的子模块和第三方的依赖，也可能包含各自的页面，所以就需要把所有的页面找到，然后注册到内存中去，人工去做这件事情可能会遗漏

![096](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/096.png)

所以下面实现的功能就是**自动注册映射**

把编译后的字节码都拿到，遍历，把具有`com.imooc.router.mapping`包名的，类名以`RouterMapping`开头的，搜集类，然后创建新的类

**步骤**

![097](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/097.png)



## 注册Transform

1.在插件工程中，创建类`RouterMappingTransform`，继承自`Transform`

重点是其`transform`方法，所有的class收集好以后，会被打包传入此方法

具体的见代码

2.在`RouterPlugin`中注册`Transform`

![098](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/098.png)

3.如何验证`Transform`真的被注册了呢？

终端输入`./gradlew :app:assembleDebug`

在app的模块下的build目录->intermediates下

![099](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/099.png)



字节码插件， ASM工具，某个java文件生成字节码的插件`ASM Bytecode Outline`

查看最后生成的类

![100](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/100.png)

![101](https://github.com/winfredzen/Android-Basic/blob/master/%E8%BF%9B%E9%98%B6/image/101.png)























































