# 贝济埃曲线

在iOS这边一般叫做贝塞尔曲线，使用方式也差不多

```java
public void quadTo(float x1, float y1, float x2, float y2)
public void rQuadTo(float dx1, float dy1, float dx2, float dy2)

public void cubicTo(float x1, float y1, float x2, float y2,
                        float x3, float y3)
public void rCubicTo(float x1, float y1, float x2, float y2,
                         float x3, float y3)     
```

**1.quadTo(float x1, float y1, float x2, float y2)**

+ x1、y1 - 控制点坐标
+ x2、y2 - 终点坐标

起始点是通过`Path.moveTo(x,y)`函数指定的

如下的例子：

```java
public class QuadToDemoView extends View {
    Paint mPaint;

    public QuadToDemoView(Context context) {
        super(context);
        init();
    }

    public QuadToDemoView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public QuadToDemoView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        Paint paint = new Paint();
        paint.setStyle(Paint.Style.STROKE);
        paint.setStrokeWidth(5);
        paint.setColor(Color.BLACK);
        mPaint = paint;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        Path path = new Path();
        path.moveTo(100, 300);
        path.quadTo(200, 200, 300, 300);
        path.quadTo(400, 400, 500, 300);

        canvas.drawPath(path, mPaint);
    }
}
```

![053](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/053.png)

在捕捉手势轨迹中，一般我们是使用`Path.lineTo()`函数来把各个点连接起来，如下的例子：

```java
public class NormalGestureTrackView extends View {
    private Path mPath = new Path();
    private Paint mPaint;

    public NormalGestureTrackView(Context context, AttributeSet attrs) {
        super(context, attrs);

        mPaint = new Paint();
        mPaint.setColor(Color.BLACK);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(5);
    }


    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN: {
                mPath.moveTo(event.getX(), event.getY());
                /**
                 * ACTION_DOWN返回true，表示消耗了下按动作，之后的ACTION_MOVE ACTION_UP也会继续传递到控件中
                 * 如果ACTION_DOWN返回false，则后续的ACTION_MOVE ACTION_UP动作就不会再传递到这个控件中
                 */
                return true;
            }
            case MotionEvent.ACTION_MOVE:
                mPath.lineTo(event.getX(), event.getY());
                postInvalidate();
                break;
            default:
                break;
        }
        return super.onTouchEvent(event);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.drawColor(Color.WHITE);
        canvas.drawPath(mPath,mPaint);
    }
}

```

![054](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/054.png)

**可以发现在两点的连接处有明显的转折**

要想优化这种效果，就得实现线与线之间的平滑过渡，可以使用二阶贝济埃曲线

```java
public class BezierGestureTrackView extends View {
    private Path mPath = new Path();
    private Paint mPaint;
    private float mPreX,mPreY;

    public BezierGestureTrackView(Context context, AttributeSet attrs) {
        super(context, attrs);


        mPaint = new Paint();
        mPaint.setColor(Color.BLACK);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(5);
    }

    @Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()){
        case MotionEvent.ACTION_DOWN:{
            mPath.moveTo(event.getX(),event.getY());
            mPreX = event.getX();
            mPreY = event.getY();
            return true;
        }
        case MotionEvent.ACTION_MOVE:{
            float endX = (mPreX+event.getX())/2;
            float endY = (mPreY+event.getY())/2;
            mPath.quadTo(mPreX,mPreY,endX,endY);
            mPreX = event.getX();
            mPreY =event.getY();
            invalidate();
        }
        break;
        default:
            break;
    }
    return super.onTouchEvent(event);
}

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.drawColor(Color.WHITE);
        canvas.drawPath(mPath,mPaint);
    }
}
```

**2.rQuadTo(float dx1, float dy1, float dx2, float dy2)**

4个参数都是相对值，即相对上一个终点的位移值

+ dx1 - 控制点x坐标，表示相对上一个终点x坐标的位移坐标。可为负值，正值表示相加，负值表示相减
+ dy1 - 控制点y坐标，表示相对上一个终点y坐标的位移坐标
+ dx2 - 终点x坐标，表示相对上一个终点x坐标的位移值
+ dy2 - 终点y坐标，表示相对上一个终点y坐标的位移值

比如上一个坐标是`(300, 400)`，利用`rQuadTo(100, -100, 200, 100)`得到的控制点坐标是`(300+100, 400-100)`，即`(400, 300)`, 得到终点坐标是`(300+200, 400+100)`，即`(500, 500)`

上面使用`quadTo`来实现波浪线

```java
Path path = new Path();
path.moveTo(100, 300);
path.quadTo(200, 200, 300, 300);
path.quadTo(400, 400, 500, 300);
```

使用`rQuadTo`来实现

```java
Path path = new Path();
path.moveTo(100, 300);
path.rQuadTo(100, -100, 200, 0);
path.rQuadTo(100, 100, 200, 0);
```



**波浪效果**

使用`rQuadTo`来实现波浪效果，先绘制可以铺满整个屏幕宽度的波，如下：

```java
public class WaveView extends View {
    private Paint mPaint;
    private Path mPath;
    private int mItemWaveLength = 400; //波长
    private int dx;

    public WaveView(Context context) {
        super(context);
        init();
    }

    public WaveView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public WaveView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        mPaint = new Paint();
        mPath = new Path();
        mPaint.setColor(Color.GREEN);
        mPaint.setStyle(Paint.Style.FILL);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        mPath.reset();
        int originY = 200;
        int halfWaveLen = mItemWaveLength / 2;
        mPath.moveTo(-mItemWaveLength, originY);

        for (int i = -mItemWaveLength; i <= getWidth() + mItemWaveLength; i += mItemWaveLength) {
            mPath.rQuadTo(halfWaveLen / 2, -100, halfWaveLen, 0);
            mPath.rQuadTo(halfWaveLen / 2, 100, halfWaveLen, 0);
        }
        canvas.drawPath(mPath, mPaint);

    }
}

```

![055](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/055.png)

**要想wave动起来，在调用`path.moveTo()`函数的时候，将起始点向右移动即可实现。而且只要移动一个波长的长度，波纹就可以重合，就可以实现无线循环**

```java
    public void startAnim() {
        ValueAnimator animator = ValueAnimator.ofInt(0, mItemWaveLength);
        animator.setDuration(2000);
        animator.setRepeatCount(ValueAnimator.INFINITE);
        animator.setInterpolator(new LinearInterpolator());
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                dx = (int) animation.getAnimatedValue();
                postInvalidate();
            }
        });
        animator.start();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        mPath.reset();
        int originY = 200;
        int halfWaveLen = mItemWaveLength / 2;
        mPath.moveTo(-mItemWaveLength + dx, originY);

        for (int i = -mItemWaveLength; i <= getWidth() + mItemWaveLength; i += mItemWaveLength) {
            mPath.rQuadTo(halfWaveLen / 2, -100, halfWaveLen, 0);
            mPath.rQuadTo(halfWaveLen / 2, 100, halfWaveLen, 0);
        }
        canvas.drawPath(mPath, mPaint);

    }
```

![056](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/056.gif)

闭合路径

```java
    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        mPath.reset();
        int originY = 200;
        int halfWaveLen = mItemWaveLength / 2;
        mPath.moveTo(-mItemWaveLength + dx, originY);

        for (int i = -mItemWaveLength; i <= getWidth() + mItemWaveLength; i += mItemWaveLength) {
            mPath.rQuadTo(halfWaveLen / 2, -100, halfWaveLen, 0);
            mPath.rQuadTo(halfWaveLen / 2, 100, halfWaveLen, 0);
        }

        //闭合
        mPath.lineTo(getWidth(), getHeight());
        mPath.lineTo(0, getHeight());
        mPath.close();

        canvas.drawPath(mPath, mPaint);

    }
```

![057](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/057.png)























































