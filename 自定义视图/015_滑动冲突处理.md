# 滑动冲突处理



## requestDisallowInterceptTouchEvent

```java

    /**
     * Called when a child does not want this parent and its ancestors to
     * intercept touch events with
     * {@link ViewGroup#onInterceptTouchEvent(MotionEvent)}.
     *
     * <p>This parent should pass this call onto its parents. This parent must obey
     * this request for the duration of the touch (that is, only clear the flag
     * after this parent has received an up or a cancel.</p>
     * 
     * @param disallowIntercept True if the child does not want the parent to
     *            intercept touch events.
     */
    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept);
```

> 当子View不想父控件拦截消息的时候回调用`requestDisallowInterceptTouchEvent(true)`函数来通知父控件，让它不要拦截消息，使消息能够流向自己
>
> + `true` - 表示禁止父控价拦截消息
> + `false` - 表示允许父控件拦截消息



总结：

1.要想`requestDisallowInterceptTouchEvent(true)`有效，不能在父控件中拦截`ACTION_DOWN`消息

2.在父控件的`dispatchTouchEvent`函数中拦截消息时，`requestDisallowInterceptTouchEvent(true)`将失效

3.只有在父控件的`onInterceptTouchEvent`函数中拦截`ACTION_MOVE`消息是，`requestDisallowInterceptTouchEvent(true)`才有效

4.在通过`requestDisallowInterceptTouchEvent(true)`禁止父控件拦截消息时，所有父控件的`onInterceptTouchEvent`函数都将被跳过



## 滑动冲突解决方法

### 外层和内层的滑动方向不一致

可以根据当前滑动方向是横向还是纵向来判断事件交给谁处理

![143](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/143.png)

根据手指移动距离可以计算出横向移动距离dx与纵向移动距离dy，比较大小

+ 如果dx > dy，则算作横向移动
+ 如果dx < dy，则算作纵向移动



### 外层与内层的滑动方向一致

如下的例子，在一个上下滑动的ScrollView中，有一个可以上下滑动的TextView

如果没有处理滑动冲突，其效果如下，当想要滑动TextView中的内容是，ScrollView也跟着滑动

![144](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/144.gif)

#### 外部拦截发

指点击事件都先经过父控件的拦截处理，如果父控件需要此事件就拦截，如果不需要就不拦截

外部拦截发需要重写父控件的`onInterceptTouchEvent`函数

如下的布局：

```xml
<?xml version="1.0" encoding="utf-8"?>
<com.sliding.harvic.slidingconflict.CustomScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <TextView
            android:id="@+id/tv"
            android:layout_width="match_parent"
            android:layout_height="100dp"
            android:background="@android:color/holo_blue_bright"
            android:maxHeight="100dp"
            android:singleLine="false"
            android:gravity="center"
            android:text="123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=\
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        ========================================================================="
            android:textSize="20dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="1000dp"
            android:background="@android:color/holo_green_light"
            android:gravity="center"
            android:text="@string/app_name"
            android:textSize="20dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="1000dp"
            android:background="@android:color/holo_green_light"
            android:gravity="center"
            android:text="@string/app_name"
            android:textSize="20dp" />

    </LinearLayout>

</com.sliding.harvic.slidingconflict.CustomScrollView>
```

`CustomScrollView`中实现外部拦截法：

```java
public class CustomScrollView extends ScrollView {
    private float mDownPointY;
    private int mConflictHeight;

    public CustomScrollView(Context context) {
        super(context);
        init(context);
    }

    public CustomScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    public CustomScrollView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(context);
    }

    private void init(Context context) {
        mConflictHeight = context.getResources().getDimensionPixelSize(R.dimen.conflict_height);//100dp
    }

    public boolean onInterceptTouchEvent(MotionEvent event) {
        boolean intercepted = false;
        switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN://绝对不能拦截ACTION_DOWN消息
            intercepted = false;
            mDownPointY = event.getY();
            break;
        case MotionEvent.ACTION_MOVE:
            if (mDownPointY < mConflictHeight) {
                intercepted = false; //不拦截
            } else {
                intercepted = true;
            }
            break;
        case MotionEvent.ACTION_UP:
            intercepted = false;
            break;
        default:
            break;
        }
        return intercepted;
    }

}
```

效果如下：

![145](https://github.com/winfredzen/Android-Basic/blob/master/自定义视图/images/145.gif)



#### 内部拦截法

指父控件不拦截任何消息，所有消息都传递给子控件，如果子控件需要此消息就直接消费掉，否则就交给父控件来处理。

需要利用`requestDisallowInterceptTouchEvent`来实现

如下的布局：

```java
<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <com.sliding.harvic.slidingconflict.CustomTextView
            android:id="@+id/tv"
            android:layout_width="match_parent"
            android:layout_height="100dp"
            android:background="@android:color/holo_blue_bright"
            android:maxHeight="100dp"
            android:singleLine="false"
            android:gravity="center"
            android:text="123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=\
                        123456789123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-=
                        ========================================================================="
            android:textSize="20dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="1000dp"
            android:background="@android:color/holo_green_light"
            android:gravity="center"
            android:text="@string/app_name"
            android:textSize="20dp" />

        <TextView
            android:layout_width="match_parent"
            android:layout_height="1000dp"
            android:background="@android:color/holo_green_dark"
            android:gravity="center"
            android:text="@string/app_name"
            android:textSize="20dp" />

    </LinearLayout>

</ScrollView>
```

自定义`CustomTextView`

```java
public class CustomTextView extends TextView {
    public CustomTextView(Context context) {
        super(context);
    }

    public CustomTextView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    public CustomTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
        case MotionEvent.ACTION_MOVE:
            getParent().requestDisallowInterceptTouchEvent(true);
            break;
        case MotionEvent.ACTION_UP:
            break;
        default:
            break;
        }
        return super.dispatchTouchEvent(event);
    }
}
```

















