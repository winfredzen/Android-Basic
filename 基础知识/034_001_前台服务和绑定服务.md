# 前台服务和绑定服务

前台服务和绑定服务的例子参考：

+ [Android Services: Getting Started](https://www.raywenderlich.com/20123726-android-services-getting-started)

源码位置：

+ [AndroidService](https://github.com/winfredzen/Android-Basic/tree/master/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/code/AndroidService)



## 前台服务

在本例子中前台服务是一个展示在通知栏的计时器，`TimerService`显示效果如下：

![074](https://github.com/winfredzen/Android-Basic/blob/master/基础知识/images/074.png)

> All apps that target Android 9 (API level 28) or higher must request permission to use a foreground service
>
> 前台服务需要添加权限
>
> ```xml
> <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
> ```

**创建前台通知**

1.获取`NotificationManager`

2.在Android 8及以后的版本，notification必须是notification channel的一部分，所以需创建`NotificationChannel`

3.`NotificationCompat.Builder`

4.构建`Notification`

```kotlin
fun getNotification(): Notification {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        notificationManager.createNotificationChannel(createChannel())
    }
    return notificationBuilder.build()
}
```

5.更新通知

```kotlin
fun updateNotification(notificationText: String? = null) {
    // 更新通知的内容文本
    notificationText?.let { notificationBuilder.setContentText(it) }
    // 通知更新
    notificationManager.notify(NOTIFICATION_ID, notificationBuilder.build())
}
```



**开启和停止服务**

```kotlin
startForeground(NotificationHelper.NOTIFICATION_ID, helper.getNotification())
```

> A started service can use the `startForeground(int, android.app.Notification)` API to put the service in a foreground state, where the system considers it to be something the user is actively aware of and thus not a candidate for killing when low on memory. (It is still theoretically possible for the service to be killed under extreme memory pressure from the current foreground application, but in practice this should not be a concern.)
>
> 启动的服务可以使用 `startForeground(int, android.app.Notification)` API 将服务置于前台状态，系统认为它是用户主动意识到的，因此在低电平时不适合杀死 记。 （理论上，在当前前台应用程序的极端内存压力下，服务仍然可能被杀死，但实际上这不应该是一个问题。）

在Activity中，启动前台服务

```kotlin
ContextCompat.startForegroundService(this, getServiceIntent(timerState))

private fun getServiceIntent(command: TimerState) =
    Intent(this, TimerService::class.java).apply {
        putExtra(SERVICE_COMMAND, command as Parcelable)
    }
```

停止服务

```java
private fun stopService() {
    //停止服务
    //  tells the system that it should remove this service from foreground state
    stopForeground(true)
    // Since a service can start itself, it must handle stopping itself, as well
    stopSelf()
}
```



## 使用后台处理进行复杂工作

1. *Custom Background Service* – by default, the service runs on the UI thread. To avoid blocking it, create a Service with a job processing on the background thread.
2. *IntentService* – a subclass of Service that executes requests sequentially by using worker thread. Since Android 8, it’s usage is *not recommended*. Also, IntentService is *deprecated* from Android 11.
3. *JobIntentService* – a replacement for IntentService. Instead of service, it uses *JobScheduler* for executing jobs. In earlier versions than Android 8, it will act just like IntentService. For more info, read the official [JobIntentService documentation](https://developer.android.com/reference/androidx/core/app/JobIntentService).
4. *Background work with WorkManager* – this is a general concept for doing background work in Android. Use it when you want to execute a periodical job in the future, or when you have some job constraints.



## 绑定服务

本例子中的绑定服务用来实现对音乐播放的控制，`MusicService`如下：

```kotlin
class MusicService : Service() {

    private var musicState = MusicState.STOP
    private var musicMediaPlayer: MediaPlayer? = null

    private val songs: List<Int> = listOf(
        R.raw.driving_ambition,
        R.raw.beautiful_dream
    )
    private var randomSongs = mutableListOf<Int>()

    //控制音乐的播放、暂停、停止、切歌
    fun runAction(state: MusicState) {
        musicState = state
        when (state) {
            MusicState.PLAY -> startMusic()
            MusicState.PAUSE -> pauseMusic()
            MusicState.STOP -> stopMusic()
            MusicState.SHUFFLE_SONGS -> shuffleSongs()
        }
    }

    // TODO: Add getNameOfSong()
    fun getNameOfSong(): String =
        resources.getResourceEntryName(randomSongs.first())
            .replaceFirstChar {
                if (it.isLowerCase()) it.titlecase(Locale.ENGLISH)
                else it.toString()
            }.replace("_", " ")



    private fun initializeMediaPlayer() {
        if (randomSongs.isEmpty()) {
            randomizeSongs()
        }
        //无限循环播放音乐
        musicMediaPlayer = MediaPlayer.create(this, randomSongs.first()).apply {
            isLooping = true
        }

    }

    private fun startMusic() {
        initializeMediaPlayer()
        musicMediaPlayer?.start()
    }

    private fun pauseMusic() {
        musicMediaPlayer?.pause()
    }

    private fun stopMusic() {
        musicMediaPlayer?.run {
            stop()
            release()
        }
    }

    private fun shuffleSongs() {
        musicMediaPlayer?.run {
            stop()
            release()
        }
        randomizeSongs()
        startMusic()
    }

    private fun randomizeSongs() {
        randomSongs.clear()
        randomSongs.addAll(songs.shuffled())
    }

    override fun onBind(intent: Intent?): IBinder = binder

    private val binder by lazy { MusicBinder() }

    /**
     * 通过扩展Binder，其它的component可以使用Binder 或者 Service的公开方法
     */
    inner class MusicBinder : Binder() {
        //获取Service对象
        fun getService(): MusicService = this@MusicService

    }


}
```

在Activity中绑定服务

```kotlin
//绑定音乐服务
private fun bindToMusicService() {
    // 1
    Intent(this, MusicService::class.java).also {
        // 2
        bindService(it, boundServiceConnection, Context.BIND_AUTO_CREATE)
    }
}

    private val boundServiceConnection = object : ServiceConnection {

        // 2
        override fun onServiceConnected(className: ComponentName, service: IBinder) {
            val binder: MusicService.MusicBinder = service as MusicService.MusicBinder
            musicService = binder.getService()
            mainViewModel.isMusicServiceBound = true
        }

        // 3
        override fun onServiceDisconnected(arg0: ComponentName) {
            musicService?.runAction(MusicState.STOP)
            musicService = null
            mainViewModel.isMusicServiceBound = false
        }
    }
```

在`onServiceConnected`中，获取到binder，通过binder获取service对象，然后就可以调用service中的方法了



**解绑**

```kotlin
unbindService(boundServiceConnection)
```

























