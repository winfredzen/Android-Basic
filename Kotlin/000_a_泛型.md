# 泛型





## reified

在开源的代码中总会见到一些使用reified的代码，如下：

```kotlin
/**
 * 添加多类型
 */
inline fun <reified M> addType(@LayoutRes layout: Int) {
    typePool[M::class.java] = { layout }
}
```

reified是什么呢？

主要参考如下的几篇文章：

+ [Java泛型-擦拭法]([擦拭法 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1265104600263968)) - 首先得明白Java泛型中有关泛型类型擦拭相关的内容

> Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型`T`视为`Object`处理，但是，在需要转型的时候，编译器会根据`T`的类型自动为我们实行安全地强制转型

如果要在Java中实例化泛型的类型，一般要使用如下的形式，借助`Class<T>`参数

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(Class<T> clazz) {
        first = clazz.newInstance();
        last = clazz.newInstance();
    }
}
```

kotlin使用reified参考如下的文章：

+ [使用Kotlin Reified 让泛型更简单安全](https://droidyue.com/blog/2019/07/28/kotlin-reified-generics/)

+ [推荐使用 Kotlin 关键字 Reified](https://juejin.cn/post/6844903833596854279)

> 1.不再需要传参数 clazz
> 
> 旧的方式：
> 
> ```kotlin
> // Function
> private fun <T : Activity> Activity.startActivity(context: Context, clazz: Class<T>) {
>     startActivity(Intent(context, clazz))
> }
> 
> // Caller
> startActivity(context, NewActivity::class.java)
> 
> 
> ```



> 新的方式:
> 
> ```kotlin
> // Function
> inline fun <reified T : Activity> Activity.startActivity(context: Context) {
>     startActivity(Intent(context, T::class.java))
> }
> 
> // Caller
> startActivity<NewActivity>(context)
> 
> 
> ```


























