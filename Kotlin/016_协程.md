# 协程

**协程的原理**

参考如下的教程：

+ [一文读懂什么是进程、线程、协程](https://www.cnblogs.com/Survivalist/p/11527949.html)

> 当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻`yield`掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为`coroutine`，而跑在由`coroutine`负责调度的线程称为`Fiber`。比如Golang里的 go关键字其实就是负责开启一个`Fiber`，让`func`逻辑跑在上面。
>
> 由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。
> 因此，协程的开销远远小于线程的开销，也就没有了`ContextSwitch`上的开销。



不错的教程：

+ [Android 上的 Kotlin 协程](https://developer.android.com/kotlin/coroutines?hl=zh-cn)
+ [史上最详Android版kotlin协程入门进阶实战(一)](https://juejin.cn/post/6953441828100112392)

参照上面的教程，记录学习的笔记

app的`build.gradle`中引用相关配置

```java
    // Kotlin
    implementation "org.jetbrains.kotlin:kotlin-stdlib:1.4.32"
    // 协程核心库
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3"
    // 协程Android支持库
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.3"
```

> However, a coroutine is not bound to any particular thread. It may suspend its execution in one thread and resume in another one.
> 
> 协程并不会绑定到一个特定的线程。它可以在一个线程挂起，然后在另一个线程恢复

如下的例子，点击按钮时执行如下的程序：

```kotlin
binding.submitButton.also {
    it.setOnClickListener {
        main()
        println("after main()")
    }
}


fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println("World inner!") // print after delay
    }
    println("Hello out!") // main coroutine continues while a previous one is delayed
}
```

运行时输出：

```kotlin
I/System.out: Hello out!
I/System.out: World inner!
I/System.out: after main()
```

> `runBlocking`方法的定义如下：
> 
> ```kotlin
> public fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T
> 
> ```

> Runs a new coroutine and blocks the current thread interruptibly until its completion. 
> 
> `runBlocking`会足阻塞当前的线程直至完成



> `launch`是一个协程构建器，它启动一个新的协程，该协程并能继续工作
> 
> `launch` is declared only in the CoroutineScope



> Coroutines follow a principle of structured concurrency which means that new coroutines can be only launched in a specific CoroutineScope which delimits the lifetime of the coroutine. The above example shows that runBlocking establishes the corresponding scope and that is why the previous example waits until World! is printed after a second's delay and only then exits.
> 
> 协程遵循结构化并发的原则，这意味着新的协程只能在限定协程生命周期的特定 CoroutineScope 中启动。 上面的例子表明 `runBlocking` 建立了相应的作用域，这就是为什么前面的例子要等到 `World! `延迟一秒后打印，然后才退出。



还可以使用`coroutineScope`构建器，来声明自己的作用域。它创建了一个协程范围，并且在所有启动的子项完成之前不会完成。

`runBlocking` 和 `coroutineScope` 构建器可能看起来相似，因为它们都等待它们的主体及其所有子节点完成。 主要区别在于 runBlocking 方法阻塞当前线程来，**而 coroutineScope 只是挂起，释放底层线程用于其他用途**。 由于这种差异，runBlocking 是一个常规函数，而 coroutineScope 是一个挂起函数。



```kotlin
    fun main() = runBlocking {
        doWorld()
    }

    suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
        launch {
            delay(1000L)
            println("World!")
        }
        println("Hello")
    }
```

```kotlin
I/System.out: Hello
I/System.out: World!
I/System.out: after main()
```



coroutineScope 构建器可用于任何挂起函数内以执行多个并发操作。如下，启动2个并发协程

```kotlin
    // Sequentially executes doWorld followed by "Done"
    fun main() = runBlocking {
        doWorld()
        println("Done")
    }

    // Concurrently executes both sections
    suspend fun doWorld() = coroutineScope { // this: CoroutineScope
        launch {
            delay(2000L)
            println("World 2")
        }
        launch {
            delay(1000L)
            println("World 1")
        }
        println("Hello")
    }
```

输出结果为：

```kotlin
2021-12-24 14:29:15.423 29664-29664/com.example.coroutine I/System.out: Hello
2021-12-24 14:29:16.431 29664-29664/com.example.coroutine I/System.out: World 1
2021-12-24 14:29:17.430 29664-29664/com.example.coroutine I/System.out: World 2
2021-12-24 14:29:17.430 29664-29664/com.example.coroutine I/System.out: Done
2021-12-24 14:29:17.430 29664-29664/com.example.coroutine I/System.out: after main()
```



## launch



`launch`方法的定义如下：

```kotlin
fun CoroutineScope.launch(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -> Unit): Job
```

注意，其返回值为一个`Job`，`Job`其实是一个接口

```kotlin
public interface Job : CoroutineContext.Element
```

> A launch coroutine builder returns a Job object that is a handle to the launched coroutine and can be used to explicitly wait for its completion
> 
> launch协程构建器返回一个 Job 对象，该对象是已启动协程的句柄，可用于显式等待其完成。

如下的例子，等待子协程完成，然后打印`Done`字符串

```kotlin
val job = launch { // launch a new coroutine and keep a reference to its Job
    delay(1000L)
    println("World!")
}
println("Hello")
job.join() // wait until child coroutine completes
println("Done")
```

```kotlin
Hello
World!
Done
```



协程是轻量级的，如下启动了100K个协程

```kotlin
import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking {
    repeat(100_000) { // launch a lot of coroutines
        launch {
            delay(5000L)
            print(".")
        }
    }
}
//sampleEnd
```



## async

**默认为顺序执行**

协程中的代码，就像在常规代码中一样，默认情况下是顺序的。

```kotlin
    fun main() = runBlocking<Unit> {
        val time = measureTimeMillis {
            val one = doSomethingUsefulOne()
            val two = doSomethingUsefulTwo()
            println("The answer is ${one + two}")
        }
        println("Completed in $time ms")
    }

    suspend fun doSomethingUsefulOne(): Int {
        delay(1000L) // pretend we are doing something useful here
        return 13
    }

    suspend fun doSomethingUsefulTwo(): Int {
        delay(1000L) // pretend we are doing something useful here, too
        return 29
    }
```

此时的输出结果为，大概花费了`2011 ms`：

```kotlin
2021-12-24 14:57:53.762 30216-30216/com.example.coroutine I/System.out: The answer is 42
2021-12-24 14:57:53.762 30216-30216/com.example.coroutine I/System.out: Completed in 2011 ms
```



但如果没有顺序上的依赖，我们想执行的快一些，即同时并发的执行，这就要用到`async`了

`async`跟`launch`相比大概差不多，它启动一个单独的协程，这是一个与所有其他协程同时工作的轻量级线程。

```kotlin
    fun main() = runBlocking<Unit> {
        val time = measureTimeMillis {
            val one = async { doSomethingUsefulOne() }
            val two = async { doSomethingUsefulTwo() }
            println("The answer is ${one.await() + two.await()}")
        }
        println("Completed in $time ms")
    }
```

此时的输出结果为，大概花费了`1014 ms`：

```kotlin
2021-12-24 15:05:15.858 30398-30398/com.example.coroutine I/System.out: The answer is 42
2021-12-24 15:05:15.858 30398-30398/com.example.coroutine I/System.out: Completed in 1014 ms
```

`async`方法定义如下：

```kotlin
public fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T>
```

其返回值为`Deferred`类型，`Deferred`也继承自`Job`

> You can use `.await()` on a deferred value to get its eventual result, but `Deferred` is also a `Job`, so you can cancel it if needed.
> 
> 可使用`.await()`获取最后的结果，`Deferred`也是一个`Job`，你也可以取消它

![](https://github.com/winfredzen/Android-Basic/blob/master/Kotlin/images/021.png)



**Lazily started async﻿**

通过设置`start`参数为`CoroutineStart.LAZY`。此时仅在`await`需要结果，或者Job调用去`start`方法时，才启动线程

```kotlin
val time = measureTimeMillis {
    val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }
    val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }
    // some computation
    one.start() // start the first one
    two.start() // start the second one
    println("The answer is ${one.await() + two.await()}")
}
println("Completed in $time ms")
```



















