# 内存优化总结

内存不足，Android触发GC

GC采用的是垃圾标记算法，为根搜索算法。进行可达性分析

![021](https://github.com/winfredzen/Android-Basic/blob/master/%E4%BC%98%E5%8C%96/images/021.png)

内存泄漏就是没有用的对象到GC Roots是可达的（被引用），导致GC无法回收该对象



## 内存泄漏的场景

1.非静态内部类会持有外部类实例的引用

2.匿名内部类持有外部类实例的引用

使用静态内部类解决

3.Handler内存泄漏

+ 静态Handler内部类+弱引用
+ 在`onDestroy`方法中移除`MessageQueue`中的消息



4.未正确使用Context，例如单例类持有某个Activity的context

使用Application Context来解决



5.静态的View

6.WebView

为WebView单开一个进程，使用AIDL与应用的主进程进行通信



7.资源对象未关闭，比如Cursor、File

8.集合中对象没有清理

9.Bitmap对象，Bitmap对象未回收

10.监听器未关闭，register后要unregister



## 其它

### LiveData

在应用中observe了LiveData，也需要remove



### DialogFragment 内存泄漏

在项目中使用DialogFragment展示了一个Loading框，使用LeakCanary提示内存泄漏了

参考：

+ [记录一次DialogFragment 内存泄漏](https://www.jianshu.com/p/f4c290b6b6f5)



### Retrofit

```java
public class MoviesActivity extends Activity {
    private TextView mNoOfMoviesThisWeek;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.layout_movies_activity);
        mNoOfMoviesThisWeek = (TextView) findViewById(R.id.no_of_movies_text_view);
        MoviesRepository repository = ((MoviesApp) getApplication()).getRepository();
        repository.getMoviesThisWeek()
                .enqueue(new Callback<List<Movie>>() {
                    
                    @Override
                    public void onResponse(Call<List<Movie>> call,
                                           Response<List<Movie>> response) {
                        int numberOfMovies = response.body().size();
                        mNoOfMoviesThisWeek.setText("No of movies this week: " + String.valueOf(numberOfMovies));
                    }
                    @Override
                    public void onFailure(Call<List<Movie>> call, Throwable t) {
                        // Oops.
                    }
                });
    }
}
```

如果这个网络请求执行速度非常慢，并且在调用结束之前 Activity 因为某种情况被旋转了屏幕或者被销毁，**那么整个Activity实例都会被泄漏**。



参考：

+ [Does calling retrofit 2 in ViewModel can cause memory leak?](https://stackoverflow.com/questions/52192873/does-calling-retrofit-2-in-viewmodel-can-cause-memory-leak)

+ [Why callback method for asynchronous network call can't cause memory leak when activity finished?](https://stackoverflow.com/questions/49064577/why-callback-method-for-asynchronous-network-call-cant-cause-memory-leak-when-a)



也看参考：[Android 内存泄漏 ——检测、解决和避免](https://juejin.cn/post/6844903464384856071)解决Retrofit的内存泄漏问题







## 工具

**1.Memory Profile**

a.大内存申请与GC

b.内存抖动 - 短时间内，发生了多次内存的分配与释放，严重的内存抖动还会导致应用卡顿

**2.MAT**

生成hprof文件



**3.LeakCanary**



## 小技巧

### 模拟MainActivity销毁的情况

参考：

+ [怎么模拟Activity被系统杀死](https://juejin.cn/post/6844903942871056398)



> 在真机中的设置——开发者选项——不保留活动(dont keep activity)，开启这个选项。 该选项开启后的作用是当Activity实例执行了onStop后，就会被系统杀死。所以当前的可见页面是APP唯一Activity，当我们按Home键后，该Activity也执行onStop，然后被系统杀死。这种行为其实就相当于我们的APP被系统杀死了一样。















