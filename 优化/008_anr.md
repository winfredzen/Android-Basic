# anr

参考：

+ [应用与系统稳定性第一篇---ANR问题分析的一般套路](https://www.jianshu.com/p/18f16aba79dd)



## 原因

参考官方文档：

+ [ANR](https://developer.android.com/topic/performance/vitals/anr?hl=zh-cn)



> - **输入调度超时**：如果您的应用在 5 秒内未响应输入事件（例如按键或屏幕触摸）。
> - **执行服务**：如果应用声明的服务无法在几秒内完成 `Service.onCreate()` 和 `Service.onStartCommand()`/`Service.onBind()` 执行。
> - **未调用 Service.startForeground()**：如果您的应用使用 `Context.startForegroundService()` 在前台启动新服务，但该服务在 5 秒内未调用 `startForeground()`。
> - **intent 广播**：如果 [`BroadcastReceiver`](https://developer.android.com/reference/android/content/BroadcastReceiver?hl=zh-cn) 在设定的一段时间内没有执行完毕。如果应用有任何前台 activity，此超时期限为 5 秒。



> Input事件超过5s没有被处理完
>
> Service处理超时，前台20s，后台200s
>
> BroadcastReceiver处理超时，前台10S，后台60s
>
> ContentProvider执行超时，比较少见



发生ANR可能原因

> 主线程有耗时操作，如有复杂的layout布局，IO操作等。
>
> 被Binder对端block
>
> 被子线程同步锁block
>
> Binder被占满导致主线程无法和SystemServer通信
>
> 得不到系统资源（CPU/RAM/IO）





## 类型



### 1. `IPCThreadState::waitForResponse`

![017](https://github.com/winfredzen/Android-Basic/blob/master/%E4%BC%98%E5%8C%96/images/017.png)

网路上有说是：

> **binder线程池被占满**系统对每个process最多分配15个binder线程，这个是谷歌的设计（/frameworks/native/libs/binder/ProcessState.cpp)如果另一个process发送太多重复binder请求，那么就会导致接收端binder线程被占满，从而处理不了其它的binder请求

我自己无法确定

参考：

+ [Binder开辟线程数过多导致主线程ANR异常](https://blog.csdn.net/chuyouyinghe/article/details/125614064)



## 原因



###  1. SharedPreference阻塞主线程

参考：

+ [深入 SharedPreferences：架构、缺点和优化](https://www.dalvik.work/2022/05/16/sharedpreferences/#)



> 构造 `SharedPreferences` 实例时会立即起一个线程来将磁盘上的 `xml` 文件加载并解析为内存中的 `Map`，在加载任务完成前，会通过 `mLock` 阻塞所有的 `get/set` 操作



















