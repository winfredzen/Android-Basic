# 绘制三角形

参考：

+ 《Opengl es 3.0 编程指南》



我想使用两种方式来绘制三角形，主要是在OpenGL es 3.0中，有些api的用法跟原来相比有些区别，主要是想对比下

1.OpenGL如何怎样把我们定义的坐标映射到屏幕上的实际物理坐标

无论是x坐标还是y左边，OpenGL都会把屏幕映射到`[-1, 1]`的范围内。屏幕的左边对应x轴的-1，屏幕的右边对应+1，屏幕的底边对应y轴的-1，屏幕的顶边对应+1

![005](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/005.png)



2.使数据可以被OpenGL存取

参考：

+ [OpenGL 学习系列---基础的绘制流程](https://glumes.com/post/opengl/opengl-tutorial-draw-point/)

> 当定义完了顶点坐标，并且明确了下一步：**顶点坐标将要通过渲染管线进行一系列处理**，那么接下来就是如何把顶点坐标传递给渲染管线了。
>
> OpenGL 的实现是由显示设备厂商提供的，它作为本地系统库直接运行在硬件上。而我们定义的顶点 Java 代码是运行在虚拟机上的，这就涉及到了如何把 Java 层的内存复制到 Native 层了。
>
> 一种方法是直接使用`JNI`开发，直接调用本地系统库，也就是用 `C++` 来开发 OpenGL，这种实现肯定要学会的。
>
> 另一种方法就是在 Java 层把内存块复制到 Native 层。
>
> 使用`ByteBuffer.allocateDirect()`方法就可以分配一块 Native 内存，这块内存不会被 Java 的垃圾回收器管理。
>
> 它的使用方法大致都一样，抽出公共的模板：
>
> ```java
>    // 声明一个字节缓冲区 FloatBuffer
>    private FloatBuffer floatBuffer;
>    // 定义顶点数据
>    float[] vertexData = new float[16];
>    // FloatBuffer 初始化工作并放入顶点数据
>    floatBuffer = ByteBuffer
>        .allocateDirect(vertexData.length * Constant.BYTES_PRE_FLOAT)
>        .order(ByteOrder.nativeOrder())
>        .asFloatBuffer()
>        .put(vertexData);
> ```



**3.着色器**

顶点着色器（vertex shader） - 生成每个顶点的最终位置，针对每个顶点，它都会执行一次。一旦最终位置确定了，OpenGL就可以把这些可见顶点的集合组装成点、直线以及三角形

片段着色器（fragment shader）- 为组成点、直线或者三角形的每个片段生成最终的颜色，针对每个片段 ，它都会执行一次；一个片段是一个小的、单一颜色的长方形区域，类似于计算机屏幕上的一个像素

![008](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/008.png)

一旦最终的颜色生成了，OpenGL就会把它们写到一块称为帧缓冲区（frame buffer）的内存区块中，然后，Android会把这个帧缓冲区显示到屏幕上

![006](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/006.png)





## 2.0方式

如下的例子，创建一个白色的三角形，实现如下，详情可见注释，`TriangleRender02`：

```java
public class TriangleRender02 implements GLSurfaceView.Renderer {
    private static final String TAG = "TriangleRender02";

    //每个FLOAT占据4个字节
    private static final int BYTES_PER_FLOAT = 4;
    //顶点数据FloatBuffer
    private FloatBuffer vertexData;
    //存储链接程序的id
    private int program;
    //颜色常量和位置
    private static final String U_COLOR = "u_Color";
    private int uColorLocation;
    //属性常量和位置
    private static final String A_POSITION = "a_Position";
    private int aPositionLocation;

    //每个position的由x y z组成
    private static final int POSITION_COMPONENT_COUNT = 3;

    private static final String vertexShaderSource = "attribute vec4 a_Position;\n"
            + "void main()\n"
            + "{\n"
            + "   gl_Position = a_Position;\n"
            + "}";

    private static final String fragmentShaderSource = "precision mediump float; \n"
            + "uniform vec4 u_Color;\n"
            + "void main()\n"
            + "{\n"
            + "    gl_FragColor = u_Color;\n"
            + "}";

    float[] vertices = {
            -0.5f, -0.5f, 0.0f,
            0.5f, -0.5f, 0.0f,
            0.0f,  0.5f, 0.0f
    };

    public TriangleRender02() {
        /**
         * 1.通过allocateDirect分配本地的内存
         * 2.按照本地字节组织（其它如，大端序、小端序，但重要的是一个平台要使用同样的排序）
         */
        vertexData = ByteBuffer.allocateDirect(vertices.length * BYTES_PER_FLOAT)
                .order(ByteOrder.nativeOrder())
                .asFloatBuffer();
        vertexData.put(vertices);
        vertexData.position(0);

    }

    @Override
    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
        //顶点着色器
        //1.创建一个新的着色器
        int vertexShader = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);
        //2.上传和编译着色器
        GLES20.glShaderSource(vertexShader, vertexShaderSource);
        GLES20.glCompileShader(vertexShader);
        //3.取出编译状态，检测在调用glCompileShader后编译是否成功了
        final int[] compileStatus = new int[1];
        GLES20.glGetShaderiv(vertexShader, GLES20.GL_COMPILE_STATUS, compileStatus, 0);
        if (compileStatus[0] == 0) {
            Log.v(TAG, "检测编译时错误: " + GLES20.glGetShaderInfoLog(vertexShader));
        }

        //片段着色器
        int fragmentShader = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER);
        GLES20.glShaderSource(fragmentShader, fragmentShaderSource);
        GLES20.glCompileShader(fragmentShader);
        //检测在调用glCompileShader后编译是否成功了
        GLES20.glGetShaderiv(fragmentShader, GLES20.GL_COMPILE_STATUS, compileStatus, 0);
        if (compileStatus[0] == 0) {
            Log.v(TAG, "检测编译时错误: " + GLES20.glGetShaderInfoLog(fragmentShader));
        }

        //创建程序对象
        program = GLES20.glCreateProgram();
        //附加上着色器
        GLES20.glAttachShader(program, vertexShader);
        GLES20.glAttachShader(program, fragmentShader);
        //连接程序
        GLES20.glLinkProgram(program);

        GLES20.glUseProgram(program);

        final int[] linkStatus = new int[1];
        GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0);
        if (linkStatus[0] == 0) {
            Log.v(TAG, "检测链接着色器程序: " + GLES20.glGetProgramInfoLog(program));
        }

        //告诉OpenGL在绘制任何东西到屏幕上的时候使用这里定义的程序
        GLES20.glUseProgram(program);

        //获取uniform的位置，并把位置存入uColorLocation
        uColorLocation = GLES20.glGetUniformLocation(program, U_COLOR);
        //获取属性位置
        aPositionLocation = GLES20.glGetAttribLocation(program, A_POSITION);
        //关联属性与顶点数据
        GLES20.glVertexAttribPointer(aPositionLocation, POSITION_COMPONENT_COUNT, GLES20.GL_FLOAT, false, 0, vertexData);
        //使能顶点数组，调用后，OpenGL就知道去哪里找它所需要的数据了
        GLES20.glEnableVertexAttribArray(aPositionLocation);

    }

    @Override
    public void onSurfaceChanged(GL10 gl, int width, int height) {
        GLES30.glViewport(0, 0, width, height);
    }

    @Override
    public void onDrawFrame(GL10 gl) {
        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);

        //更新着色器代码中u_Color的值
        GLES20.glUniform4f(uColorLocation, 1.0f, 1.0f, 1.0f, 1.0f);
        //绘制
        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);
        
    }
}

```

效果如下：

![007](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/007.png)



### 进一步的解释

#### 1.顶点着色器

```java
    private static final String vertexShaderSource = "attribute vec4 a_Position;\n"
            + "void main()\n"
            + "{\n"
            + "   gl_Position = a_Position;\n"
            + "}";
```

对应我们定义的每一个顶点，顶点着色器都会被调用一次。

+ 被调用时，在a_Position接收当前的顶点位置，这个属性被定义为vec4类型
+ vec4包含4个分量，x、y、z、w。x、y、z表示的是三维的坐标，w是一个特殊的坐标
+ 顶点有有位置、颜色属性，attribute关键字就是把这些属性放进着色器的手段
+ `main()`是着色器的主要入口
+ `gl_Position = a_Position`表示的是，把前面定义过的位置复制到指定的输出变量`gl_Position`。OpenGL会把`gl_Position`中存储的值作为当前顶点的最终位置，并把这些顶点组装成点、直线和三角形



#### 2.片段着色器

```java
    private static final String fragmentShaderSource = "precision mediump float; \n"
            + "uniform vec4 u_Color;\n"
            + "void main()\n"
            + "{\n"
            + "    gl_FragColor = u_Color;\n"
            + "}";
```

1.`precision mediump float;`定义了所有浮点类型数据的精度。可以选择lowp、mediump、highp。高精度数据类型更加精确，代价就是会降低性能

2.`uniform`会让每个顶点使用同一个值，除非再次改变它

3.颜色是个4分量，分别对应红色、绿色、蓝色、alpha

4.将颜色复制到输出变量`gl_FragColor`



#### 3.glVertexAttribPointer

`glVertexAttribPointer`定义如下：

```java
    public static void glVertexAttribPointer(
        int indx,
        int size,
        int type,
        boolean normalized,
        int stride,
        java.nio.Buffer ptr
    ) 
```

在案例中，是这样使用的

```java
GLES20.glVertexAttribPointer(aPositionLocation, POSITION_COMPONENT_COUNT, GLES20.GL_FLOAT, false, 0, vertexData);
```

用来关联属性与顶点数据的数组，即从`vertexData`中找到`a_Position`对应的数据

+ index - 属性的位置
+ size - 每个属性的数据的计数（对于这个属性，有多少个分量与每一个顶点相关联）。这里每个顶点使用三个浮点数，所以为3
+ type - 数据类型
+ normalized - 只有使用整型数据，这个参数才有意义
+ stride - 只有当一个数组存储多余一个属性时，它才有意义。（我们这里的vertexData中存放都是顶点的位置，所以直接传0。如果vertexData不光有顶点的位置，还有顶点的其它属性（如颜色数据），就需要设置stride了）
+ ptr - 这个参数告诉OpenGL去哪里读取数据







## 3.0方式

这种方式，主要参考：

+ [你好，三角形](https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/)



`TriangleRender`代码主要如下，详情可参见注释：

```java
public class TriangleRender implements GLSurfaceView.Renderer {
    private static final String TAG = "TriangleRender";

    private static final String vertexShaderSource = "#version 300 es\n"
            + "layout (location = 0) in vec3 aPos;\n"
            + "void main()\n"
            + "{\n"
            + "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
            + "}";

    private static final String fragmentShaderSource = "#version 300 es\n"
            + "out vec4 FragColor;\n"
            + "void main()\n"
            + "{\n"
            + "FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
            + "}";

    float[] vertices = {
            -0.5f, -0.5f, 0.0f,
            0.5f, -0.5f, 0.0f,
            0.0f,  0.5f, 0.0f
    };

    private FloatBuffer floatBuffer;

    //顶点缓冲对象：Vertex Buffer Object，VBO
    int[] vbo = new int[1];
    //顶点数组对象：Vertex Array Object，VAO
    int[] vao = new int[1];

    public TriangleRender() {
        floatBuffer = ByteBuffer.allocateDirect(vertices.length * 4)
                .order(ByteOrder.nativeOrder())
                .asFloatBuffer();
        floatBuffer.put(vertices);
        floatBuffer.position(0);

    }

    @Override
    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
        //顶点着色器
        int vertexShader = GLES30.glCreateShader(GLES30.GL_VERTEX_SHADER);
        GLES30.glShaderSource(vertexShader, vertexShaderSource);
        GLES30.glCompileShader(vertexShader);
        //检测在调用glCompileShader后编译是否成功了
        final int[] compileStatus = new int[1];
        GLES30.glGetShaderiv(vertexShader, GLES30.GL_COMPILE_STATUS, compileStatus, 0);
        if (compileStatus[0] == 0) {
            Log.v(TAG, "检测编译时错误: " + GLES30.glGetShaderInfoLog(vertexShader));
        }

        //片段着色器
        int fragmentShader = GLES30.glCreateShader(GLES30.GL_FRAGMENT_SHADER);
        GLES30.glShaderSource(fragmentShader, fragmentShaderSource);
        GLES30.glCompileShader(fragmentShader);
        //检测在调用glCompileShader后编译是否成功了
        GLES30.glGetShaderiv(fragmentShader, GLES30.GL_COMPILE_STATUS, compileStatus, 0);
        if (compileStatus[0] == 0) {
            Log.v(TAG, "检测编译时错误: " + GLES30.glGetShaderInfoLog(fragmentShader));
        }

        //创建程序对象
        int program = GLES30.glCreateProgram();
        GLES30.glAttachShader(program, vertexShader);
        GLES30.glAttachShader(program, fragmentShader);
        GLES30.glLinkProgram(program);
        //检测链接着色器程序是否失败
        final int[] linkStatus = new int[1];
        GLES30.glGetProgramiv(program, GLES30.GL_LINK_STATUS, linkStatus, 0);
        if (linkStatus[0] == 0) {
            Log.v(TAG, "检测链接着色器程序: " + GLES30.glGetProgramInfoLog(program));
        }

        //
        GLES30.glUseProgram(program);

        GLES30.glGenBuffers(1, vbo, 0);
        GLES30.glBindBuffer(GLES30.GL_ARRAY_BUFFER, vbo[0]);
        //把之前定义的顶点数据复制到缓冲的内存中
        GLES30.glBufferData(GLES30.GL_ARRAY_BUFFER, vertices.length * 4, floatBuffer, GLES30.GL_STATIC_DRAW);//把数据存储到GPU中

        //将顶点位置数据送入渲染管线
        GLES30.glVertexAttribPointer(0, 3, GLES30.GL_FLOAT, false, 0, 0);
        //启用顶点位置属性
        GLES30.glEnableVertexAttribArray(0);

    }

    @Override
    public void onSurfaceChanged(GL10 gl, int width, int height) {
        GLES30.glViewport(0, 0, width, height);
    }

    @Override
    public void onDrawFrame(GL10 gl) {
        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);

        GLES30.glBindVertexArray(vao[0]);

        //6. 开始绘制三角形
        GLES30.glDrawArrays(GLES30.GL_TRIANGLES, 0, 3);

        //7. 解绑VAO
        GLES30.glBindVertexArray(0);

    }


}
```

其效果如下：

![009](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/009.png)



### 进一步的解释

#### 1.顶点着色器

```java
    private static final String vertexShaderSource = "#version 300 es\n"
            + "layout (location = 0) in vec3 aPos;\n"
            + "void main()\n"
            + "{\n"
            + "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
            + "}";
```

1.`#version 300 es`声明版本声明

2.通过`layout (location = 0)`设定了输入变量的位置值(Location)

3.使用`in`关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)



#### 2.片段着色器

```java
    private static final String fragmentShaderSource = "#version 300 es\n"
            + "out vec4 FragColor;\n"
            + "void main()\n"
            + "{\n"
            + "FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
            + "}";
```

1.片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。声明输出变量可以使用`out`关键字，这里我们命名为FragColor。





