# 空气曲棍球的例子

主要内容来自：`OpenGL ES应用开发实践指南  Android卷` 

要绘制就先要定义顶点坐标

**在OpenGL中只能绘制点、直线以及三角形**

> 所以如果我们想要绘制一个方向，可以用2个三角形来组织它
>
> ![010](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/010.png)
>
> ![011](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/011.png)

另外在定义三角形时，以逆时针的顺序来定义

> 以逆时针的顺序排列顶点，称为卷曲顺序（winding order）。在任何地方都可以使用这种一致的卷曲顺序，可以优化性能：使用卷曲顺序可以指出一个三角形属于任何给定物体的前面或后面，OpenGL可以忽略那些无能如何都无法被看到的后面的三角形



**数据**

1.Java代码是运行在虚拟机上的，运行在虚拟机上的代码不能访问本地环境（native environment），除非通过特定的API

2.虚拟机使用了垃圾回收机制，这意味着虚拟机检查到一个变量、对象或其它内存片段不再被使用时，就会把这些内存释放掉以备重用。但本地环境并不是这样工作的，它不期望内存块被移来移去或者被释放

OpenGL作为本地系统库直接运行在硬件上，没有虚拟机，也没有垃圾回收或者内存压缩



**Java调用本地代码**

1.使用Java本地接口(JNI)

2.改变内存分配的方式。Java有一个特殊的类集合，它们可以分配本地内存块，并且把Java的数据复制到本地内存。本地内存可以被本地环境存取，而不受垃圾回收器的管控



在`raw`文件夹中定义顶点着色器和片段着色器

![012](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/012.png)

**1.顶点着色器**

```java
attribute vec4 a_Position;

void main()
{
    gl_Position = a_Position;
}
```

> 定义过的每个单一的顶点，顶点着色器都会被调用一次。调用的时候，会在`a_Position`属性里接收当前顶点的位置
>
> 这个属性被定义为`vec4`类型。vec4包含4个分量，x、y、z、w。x、y、z表示的是三维的坐标，w是一个特殊的坐标。如果没有指定，默认情况下，OpenGL都是把前三个坐标设为0，并把最后一个坐标设为1
>
> 关键词`attribute`就是把属性放进着色器的手段
>
> `main()`着色器的主要入口，就是把前面定义的位置复制到指定的输出位置`gl_Position`

**2.片段着色器**

```java
precision mediump float;

uniform vec4 u_Color;

void main()
{
    gl_FragColor = u_Color;
}
```

> `uniform`会让每个顶点都使用同一个值，除非再次改变它

封装工具类，从Raw中读取文件内容，`TextResourceReader`

```java
public class TextResourceReader {

    public static String readTextFileFromResource(Context context, int resourceId) {
        StringBuilder body = new StringBuilder();

        try {
            InputStream inputStream =
                    context.getResources().openRawResource(resourceId);
            InputStreamReader inputStreamReader =
                    new InputStreamReader(inputStream);
            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

            String nextLine;

            while ((nextLine = bufferedReader.readLine()) != null) {
                body.append(nextLine);
                body.append('\n');
            }
        } catch (IOException e) {
            throw new RuntimeException(
                    "Could not open resource: " + resourceId, e);
        } catch (Resources.NotFoundException nfe) {
            throw new RuntimeException("Resource not found: " + resourceId, nfe);
        }

        return body.toString();
    }

}
```

如读取着色器代码：

```java
String vertexShaderSource = TextResourceReader.readTextFileFromResource(context, R.raw.simple_vertext_shader);
String fragmentShaderSource = TextResourceReader.readTextFileFromResource(context, R.raw.simple_fragment_shader);
```





**绘制的步骤**

1.加载着色器

2.编译着色器

3.把着色器一起链接进OpenGL的程序

> 一个OpenGL程序就是把一个顶点着色器和一个片段着色器链接在一起变成单个对象
>
> 顶点着色器和片段着色器总是一起工作的



在OpenGL的绘制中，可以将一些通用的方法封装为工具类，方便操作。如`ShaderHelper`

```java
public class ShaderHelper {
    private static final String TAG = "ShaderHelper";

    /**
     * Loads and compiles a vertex shader, returning the OpenGL object ID.
     */
    public static int compileVertexShader(String shaderCode) {
        return compileShader(GL_VERTEX_SHADER, shaderCode);
    }

    /**
     * Loads and compiles a fragment shader, returning the OpenGL object ID.
     */
    public static int compileFragmentShader(String shaderCode) {
        return compileShader(GL_FRAGMENT_SHADER, shaderCode);
    }

    /**
     * Compiles a shader, returning the OpenGL object ID.
     */
    private static int compileShader(int type, String shaderCode) {

        // Create a new shader object.
        /**
         * 创建一个新的着色器对象
         * GL_VERTEX_SHADER - 顶点着色器
         * GL_FRAGMENT_SHADER - 片段着色器
         * shaderObjectId - OpenGL对象的引用，返回值0表示失败
         */
        final int shaderObjectId = glCreateShader(type);

        if (shaderObjectId == 0) {
            if (LoggerConfig.ON) {
                Log.w(TAG, "Could not create new shader.");
            }

            return 0;
        }

        // Pass in the shader source.
        /**
         * 上传代码
         */
        glShaderSource(shaderObjectId, shaderCode);

        // Compile the shader.
        /**
         * 编译着色器
         */
        glCompileShader(shaderObjectId);

        // Get the compilation status.
        /**
         * 取出编译状态，检查编译是成功还是失败，把结果写入compileStatus的第一个值
         */
        final int[] compileStatus = new int[1];
        glGetShaderiv(shaderObjectId, GL_COMPILE_STATUS, compileStatus, 0);

        /**
         * 取出的编译状态只是一个简单的是or否，可通过glGetShaderInfoLog获取一个可读消息
         */
        if (LoggerConfig.ON) {
            // Print the shader info log to the Android log output.
            Log.v(TAG, "Results of compiling source:" + "\n" + shaderCode + "\n:"
                    + glGetShaderInfoLog(shaderObjectId));
        }

        // Verify the compile status.
        /**
         * 验证编译状态并返回着色器对象ID
         */
        if (compileStatus[0] == 0) {
            // If it failed, delete the shader object.
            glDeleteShader(shaderObjectId);

            if (LoggerConfig.ON) {
                Log.w(TAG, "Compilation of shader failed.");
            }

            return 0;
        }

        // Return the shader object ID.
        return shaderObjectId;
    }

    /**
     * Links a vertex shader and a fragment shader together into an OpenGL
     * program. Returns the OpenGL program object ID, or 0 if linking failed.
     * 把着色器一起链接进OpenGL的程序
     */
    public static int linkProgram(int vertexShaderId, int fragmentShaderId) {

        // Create a new program object.
        /**
         * 新建程序对象
         */
        final int programObjectId = glCreateProgram();

        if (programObjectId == 0) {
            if (LoggerConfig.ON) {
                Log.w(TAG, "Could not create new program");
            }

            return 0;
        }

        /**
         * 附上着色器
         * glAttachShader就是把顶点着色器和片段着色器都附件到程序对象上
         */
        // Attach the vertex shader to the program.
        glAttachShader(programObjectId, vertexShaderId);
        // Attach the fragment shader to the program.
        glAttachShader(programObjectId, fragmentShaderId);

        // Link the two shaders together into a program.
        /**
         * 链接程序
         */
        glLinkProgram(programObjectId);

        // Get the link status.
        /**
         * 检查链接是否成功
         */
        final int[] linkStatus = new int[1];
        glGetProgramiv(programObjectId, GL_LINK_STATUS, linkStatus, 0);

        if (LoggerConfig.ON) {
            // Print the program info log to the Android log output.
            Log.v(TAG, "Results of linking program:\n"
                    + glGetProgramInfoLog(programObjectId));
        }

        // Verify the link status.
        if (linkStatus[0] == 0) {
            // If it failed, delete the program object.
            glDeleteProgram(programObjectId);
            if (LoggerConfig.ON) {
                Log.w(TAG, "Linking of program failed.");
            }
            return 0;
        }

        // Return the program object ID.
        return programObjectId;
    }

    /**
     * Validates an OpenGL program. Should only be called when developing the
     * application.
     */
    public static boolean validateProgram(int programObjectId) {
        glValidateProgram(programObjectId);

        final int[] validateStatus = new int[1];
        glGetProgramiv(programObjectId, GL_VALIDATE_STATUS, validateStatus, 0);
        Log.v(TAG, "Results of validating program: " + validateStatus[0]
                + "\nLog:" + glGetProgramInfoLog(programObjectId));

        return validateStatus[0] != 0;
    }
}

```



如果定义的顶点坐标如下，则绘制的图形如下：

```java
float[] tableVerticesWithTriangles = {
        // Triangle 1
        -0.5f, -0.5f,
        0.5f,  0.5f,
        -0.5f,  0.5f,
        // Triangle 2
        -0.5f, -0.5f,
        0.5f, -0.5f,
        0.5f,  0.5f,
        // Line 1
        -0.5f, 0f,
        0.5f, 0f,
        // Mallets
        0f, -0.25f,
        0f,  0.25f
};
```

![014](https://github.com/winfredzen/Android-Basic/blob/master/OpenGL/images/014.png)



































































