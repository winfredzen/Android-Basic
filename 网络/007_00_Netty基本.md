# Netty基本

项目上需要使用长连接和服务器交互，原本考虑是直接使用Socket，但Java Socket属于阻塞式IO，虽然Java中也有NIO、AIO，但本人对这些东西也不怎么熟悉

在调研过程中，看到网络上有推荐使用MINA，然后了解到Netty

**Netty 是什么？**

> Netty 是一个异步、事件驱动的用来做高性能、高可靠性的网络应用框架，使用它可以快速轻松地开发网络应用程序，极大的简化了网络编程的复杂度。

Netty 主要优点有以下几个：

1.框架设计优雅，底层模型随意切换适应不同的网络协议要求；

2.提供很多标准的协议、安全、编码解码的支持；

3.简化了 NIO 使用中的诸多不便；

4.社区非常活跃，很多开源框架中都使用了 Netty 框架，如 Dubbo、RocketMQ、Spark 等。



推荐教程：

+ [Netty 简介](http://www.imooc.com/wiki/nettylesson/netty01.html) - imooc网的一个教程，感觉讲的很不错，起码我能看懂点





## 基本

整体的架构图

![028](https://github.com/winfredzen/Android-Basic/blob/master/网络/images/028.png)





### 粘包和拆包

首次看到**粘包和拆包**，我表示很不能理解，推荐如下的文章，可以对粘包和拆包的原因有个基本的认识

+ [Socket粘包问题的3种解决方案，最后一种最完美！](https://www.cnblogs.com/vipstone/p/14239160.html)

+ [Socket粘包问题终极解决方案—Netty版（2W字）！](https://www.cnblogs.com/vipstone/p/14270296.html)

**粘包和拆包发生的原因**

> **粘包的主要原因：**
>
> + 发送方每次写入数据 < 套接字（Socket）缓冲区大小；
>
> + 接收方读取套接字（Socket）缓冲区数据不够及时。
>
> **半包的主要原因：**
>
> + 发送方每次写入数据 > 套接字（Socket）缓冲区大小；
>
> + 发送的数据大于协议的 `MTU (Maximum Transmission Unit，最大传输单元)`，因此必须拆包。



**解决方法**

1.固定数据长度

固定数据长度，客户端在发送数据的时候，每个数据包的长度固定（比如：1024 个字节），如果发送数据不足 1024 字节时，以空格补齐；服务端则每次读取固定长度是数据；

2.分隔符

分隔符，每个数据包的结尾加一个特殊分隔符，服务端则读取到特殊分隔符则认为数据包结束；如果一次读取的数据没有结束符，则保留当前数据，等待下次读取；

3.将数据分为消息头和消息体

在头部保存了消息的数据长度，只有读取指定长度的数据就算完整数据包；

4.自定义协议

通过协议的规范进行发送和接受数据。



以上的方案 Netty 官方也考虑到了，并且为了简化开发人员的工作量，Netty 内置了常见的拆包器，具体如下：

**1. 固定长度的拆包器 `FixedLengthFrameDecoder`**

每个数据包的长度都是固定的，比如 `1024`，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 `1024` 的数据包 (ByteBuf) 传递到下一个 channelHandler。

**2. 行拆包器 `LineBasedFrameDecoder`**

它是一个特殊的分隔符拆包器，以换行符作为结束符。

**3. 分隔符拆包器 `DelimiterBasedFrameDecoder`**

可以自定义自己的分隔符。

**4. 基于长度域拆包器 `LengthFieldBasedFrameDecoder`**

是最通用的一种拆包器，有一个存放数据长度的字段，读到该字段之后，往后面的数据读取一定长度的数据即可，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。



## 心跳

1.关于心跳，网络上的文章大多将的是使用`IdleStateHandler`，在需要发送心跳的时候，会触发`userEventTriggered`的调用

可参考：

+ [Netty心跳机制](https://www.cnblogs.com/linjiqin/p/10121561.html)

2.另外一种形式是定时发送心跳包

大概有2种方式

一种是使用ScheduledExecutorService，使用定时任务的方式

如在：

+ [netty\] netty心跳检测，定时任务](https://www.cnblogs.com/wxxujian/p/12699099.html)

+ [Netty框架采用定时发送“心跳报文”，解决“心跳检测”问题](https://zhuanlan.zhihu.com/p/38320072)



## 重连机制

Socket连接后，可能由于某种原因导致连接断开，此时就需要重新连接

重新连接就有重新连接的策略，这就与具体的业务有关了，比如重连的次数、间隔时间等

参考如下的文章：

+ [Netty实现心跳机制与断线重连](https://www.jianshu.com/p/1a28e48edd92)

定义重连策略接口：

```java
public interface RetryPolicy {

    /**
     * Called when an operation has failed for some reason. This method should return
     * true to make another attempt.
     *
     * @param retryCount the number of times retried so far (0 the first time)
     * @return true/false
     */
    boolean allowRetry(int retryCount);

    /**
     * get sleep time in ms of current retry count.
     *
     * @param retryCount current retry count
     * @return the time to sleep
     */
    long getSleepTimeMs(int retryCount);
}
```



## 自定义协议

在使用Socket传输数据的时候，一般使用的都是自定义协议，自定义协议包含的部分如下

参考：

+ [07 接头暗语：如何利用 Netty 实现自定义协议通信？](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/07%20%20%E6%8E%A5%E5%A4%B4%E6%9A%97%E8%AF%AD%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Netty%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%EF%BC%9F.md)



较为通用的协议示例：

```xml
+---------------------------------------------------------------+

| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |

+---------------------------------------------------------------+

| 状态 1byte |        保留字段 4byte     |      数据长度 4byte     | 

+---------------------------------------------------------------+

|                   数据内容 （长度不定）                          |

+---------------------------------------------------------------+
```





## 编解码

Netty已经内置了很多编解码器，如StringDecoder、StringEncoder

也可以自定义编解码器，一般是继承自`MessageToByteEncoder`，`ByteToMessageDecoder`

`MessageToByteEncoder`是将消息编码成为ByteBuf，这大概是最经常使用的类，如将`Integer`转换成为`ByteBuf`

```java
       public class IntegerEncoder extends MessageToByteEncoder<Integer> {
            @Override
           public void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out)
                   throws Exception {
               out.writeInt(msg);
           }
       }
```



还有一种是`SimpleChannelInboundHandler`，**它的核心作用是自动判断数据格式类型，并且转发给对应的 Handler 来处理。**

除了上面提到的之外，还有`MessageToMessageEncoder`、`MessageToMessageDecoder`

`MessageToMessageEncoder`是在消息和消息之间进行转换，因为消息并不能直接写入到channel中，所以需要和`MessageToByteEncoder`配合使用。

`MessageToMessageDecoder`是消息和消息之间的转换，同样的只需要实现decode方法即可，如下从`String`转换到`Integer`：

```java
public class StringToIntegerDecoder extends
               MessageToMessageDecoder<String> {
  
            @Override
           public void decode(ChannelHandlerContext ctx, String message,
                              List<Object> out) throws Exception {
               out.add(message.length());
           }
       }
```



可以添加**多个编码器或者解码器**，如

```java
ChannelPipeline pipeline = ch.pipeline();
pipeline.addLast(new ToIntegerDecoder());
pipeline.addLast(new IntegerToStringDecoder());
```

可参考：

+ [Netty——Netty编解码器](https://www.jianshu.com/p/1272537dcae3)





## Protobuf

有时候数据要使用`Protobuf`协议

推荐教程：

+ [开源一个自用的Android IM库，基于Netty+TCP+Protobuf实现](https://juejin.cn/post/6844903815846559757#heading-14)



### 遇到的一些问题

参考：

+ [Netty 通讯协议功能实现](http://www.imooc.com/wiki/nettylesson/netty23.html)



在实现上文中的例子的时候，在server和client端，我都有一个User模型，但是它们的包名却是不一样的

导致在server端，解码时，出现如下的错误：

![027](https://github.com/winfredzen/Android-Basic/blob/master/网络/images/027.png)

应该是反序列化时出错了

参考：

+ [redis反序列化出现：java.lang.ClassNotFoundException异常](https://blog.csdn.net/linzhiqiang0316/article/details/102692424/)
+ [Java反序列化遇见的ClassNotFoundException](https://blog.csdn.net/liuji0517/article/details/105900570)

> 导致`java.lang.ClassNotFoundException`问题有：
>
> 1. 序列化和反序列化的`serialVersionUID`不一致。
> 2. 反序列的对象和反序列化的对象所属的包名不一致。

解决后就OK了



## Android Netty

1.在Android中引入Netty

在`mvnrepository`中查找`netty-all`，在某个版本下，对应Gradle，可能有如下的内容

```groovy
// https://mvnrepository.com/artifact/io.netty/netty-all
implementation group: 'io.netty', name: 'netty-all', version: '4.1.30.Final'
```





## 参考文档

如下的文章，本人觉的很值得参考：

+ [开源一个自用的Android IM库，基于Netty+TCP+Protobuf实现](https://juejin.cn/post/6844903815846559757#heading-12)

它的源代码地址为：[NettyChat](https://github.com/FreddyChen/NettyChat)



Netty在Android中的使用

+ [Netty在Android开发中的应用实战系列（一）——— 搭建服务端与客户端](https://blog.csdn.net/a_zhon/article/details/100569489)
+ [Netty在Android中使用](https://www.jianshu.com/p/80a077535c5f)





















