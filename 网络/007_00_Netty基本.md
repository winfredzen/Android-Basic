# Netty基本

项目上需要使用长连接和服务器交互，原本考虑是直接使用Socket，但Java Socket属于阻塞式IO，虽然Java中也有NIO、AIO，但本人对这些东西也不怎么熟悉

在调研过程中，看到网络上有推荐使用MINA，然后了解到Netty

**Netty 是什么？**

> Netty 是一个异步、事件驱动的用来做高性能、高可靠性的网络应用框架，使用它可以快速轻松地开发网络应用程序，极大的简化了网络编程的复杂度。

Netty 主要优点有以下几个：

1.框架设计优雅，底层模型随意切换适应不同的网络协议要求；

2.提供很多标准的协议、安全、编码解码的支持；

3.简化了 NIO 使用中的诸多不便；

4.社区非常活跃，很多开源框架中都使用了 Netty 框架，如 Dubbo、RocketMQ、Spark 等。



推荐教程：

+ [Netty 简介](http://www.imooc.com/wiki/nettylesson/netty01.html) - imooc网的一个教程，感觉讲的很不错，起码我能看懂点





## 基本

整体的架构图

![028](https://github.com/winfredzen/Android-Basic/blob/master/网络/images/028.png)





### 粘包和拆包

首次看到**粘包和拆包**，我表示很不能理解，推荐如下的文章，可以对粘包和拆包的原因有个基本的认识

+ [Socket粘包问题的3种解决方案，最后一种最完美！](https://www.cnblogs.com/vipstone/p/14239160.html)

+ [Socket粘包问题终极解决方案—Netty版（2W字）！](https://www.cnblogs.com/vipstone/p/14270296.html)

**粘包和拆包发生的原因**

> **粘包的主要原因：**
>
> + 发送方每次写入数据 < 套接字（Socket）缓冲区大小；
>
> + 接收方读取套接字（Socket）缓冲区数据不够及时。
>
> **半包的主要原因：**
>
> + 发送方每次写入数据 > 套接字（Socket）缓冲区大小；
>
> + 发送的数据大于协议的 `MTU (Maximum Transmission Unit，最大传输单元)`，因此必须拆包。



**解决方法**

1.固定数据长度

固定数据长度，客户端在发送数据的时候，每个数据包的长度固定（比如：1024 个字节），如果发送数据不足 1024 字节时，以空格补齐；服务端则每次读取固定长度是数据；

2.分隔符

分隔符，每个数据包的结尾加一个特殊分隔符，服务端则读取到特殊分隔符则认为数据包结束；如果一次读取的数据没有结束符，则保留当前数据，等待下次读取；

3.将数据分为消息头和消息体

在头部保存了消息的数据长度，只有读取指定长度的数据就算完整数据包；

4.自定义协议

通过协议的规范进行发送和接受数据。



以上的方案 Netty 官方也考虑到了，并且为了简化开发人员的工作量，Netty 内置了常见的拆包器，具体如下：

**1. 固定长度的拆包器 `FixedLengthFrameDecoder`**

每个数据包的长度都是固定的，比如 `1024`，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 `1024` 的数据包 (ByteBuf) 传递到下一个 channelHandler。

**2. 行拆包器 `LineBasedFrameDecoder`**

它是一个特殊的分隔符拆包器，以换行符作为结束符。

**3. 分隔符拆包器 `DelimiterBasedFrameDecoder`**

可以自定义自己的分隔符。

**4. 基于长度域拆包器 `LengthFieldBasedFrameDecoder`**

是最通用的一种拆包器，有一个存放数据长度的字段，读到该字段之后，往后面的数据读取一定长度的数据即可，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。





### 遇到的一些问题

参考：

+ [Netty 通讯协议功能实现](http://www.imooc.com/wiki/nettylesson/netty23.html)



在实现上文中的例子的时候，在server和client端，我都有一个User模型，但是它们的包名却是不一样的

导致在server端，解码时，出现如下的错误：

![027](https://github.com/winfredzen/Android-Basic/blob/master/网络/images/027.png)

应该是反序列化时出错了

参考：

+ [redis反序列化出现：java.lang.ClassNotFoundException异常](https://blog.csdn.net/linzhiqiang0316/article/details/102692424/)
+ [Java反序列化遇见的ClassNotFoundException](https://blog.csdn.net/liuji0517/article/details/105900570)

> 导致`java.lang.ClassNotFoundException`问题有：
>
> 1. 序列化和反序列化的`serialVersionUID`不一致。
> 2. 反序列的对象和反序列化的对象所属的包名不一致。

解决后就OK了



## 心跳

1.关于心跳，网络上的文章大多将的是使用`IdleStateHandler`，在需要发送心跳的时候，会触发`userEventTriggered`的调用

可参考：

+ [Netty心跳机制](https://www.cnblogs.com/linjiqin/p/10121561.html)

2.另外一种形式是定时发送心跳包

大概有2种方式

一种是使用ScheduledExecutorService，使用定时任务的方式

如在：

+ [netty\] netty心跳检测，定时任务](https://www.cnblogs.com/wxxujian/p/12699099.html)

+ [Netty框架采用定时发送“心跳报文”，解决“心跳检测”问题](https://zhuanlan.zhihu.com/p/38320072)



## Protobuf

有时候数据要使用`Protobuf`协议

推荐教程：

+ [开源一个自用的Android IM库，基于Netty+TCP+Protobuf实现](https://juejin.cn/post/6844903815846559757#heading-14)





## Android Netty

1.在Android中引入Netty

在`mvnrepository`中查找`netty-all`，在某个版本下，对应Gradle，可能有如下的内容

```groovy
// https://mvnrepository.com/artifact/io.netty/netty-all
implementation group: 'io.netty', name: 'netty-all', version: '4.1.30.Final'
```





## 参考文档

























